# 编写测试

## 测试数据（Test Data）

> "测试先行测试使用什么数据？使用使测试易于阅读和理解的数据。"

**原则**：
- 测试是为读者写的，不只是给计算机
- 如果数据之间没有概念差异，使用简单值（如1而不是2）
- 数据的差异应该有意义

**何时使用真实数据**：
- 测试实时系统，使用实际执行中收集的外部事件跟踪
- 将当前系统输出与先前系统匹配（并行测试）
- 重构模拟，期望完全相同的答案

## 显式数据（Evident Data）

> "如何表示数据的意图？在测试中包含预期和实际结果，使它们的关系显而易见。"

**原则**：
- 在断言中显示计算过程
- 从输入数据到断言数据画线
- 使连接显而易见

**示例**：

```javascript
// 不太清晰
bank.addRate("USD", "GBP", STANDARD_RATE);
bank.commission(STANDARD_COMMISSION);
assertEquals(new Note(49.25, "GBP"), result);

// 更清晰——显示计算过程
bank.addRate("USD", "GBP", 2);
bank.commission(0.0015);
assertEquals(new Note(100 / 2 * (1 - 0.0015), "GBP"), result);
```

**收益**：
- 让测试意图清晰
- 一旦在断言中写了表达式，就知道需要编程什么
- 可以用"假装实现"逐步发现操作属于哪里

## 断言（Assertion）

> "如何检查测试正确工作？编写自动判断代码是否工作的布尔表达式。"

**指南**：
- 要具体——`assertNotNull(result)` 几乎可以被任何代码满足
- 大多数xUnit实现有特殊的相等性断言
- 失败时有信息丰富的错误消息

```javascript
// 添加消息有助于调试
assertTrue("Should be true", false);
```

**黑盒 vs 白盒测试**：
- 优先使用公共协议（黑盒）
- 如果想检查内部状态，这是设计问题——改进设计机会
- 如果设计想法没出现，先检查变量，但要在备注中记录

## 测试固件（Fixture）

> "如何创建多个测试需要的公共对象？将测试中的局部变量转换为实例变量，覆盖setUp()并初始化这些变量。"

**权衡**：
- 隐式状态——不能单独读取测试，需要先建立上下文
- 编写测试更快，但阅读需要上下文

**关系**：
- 每种新固件应该是TestCase的新子类
- 每个测试方法是 TestCase 的实例

## 日志字符串（Log String）

> "如何测试消息调用顺序的正确性？在字符串中保留日志，调用消息时追加到字符串。"

**示例**：
```python
def testTemplateMethod(self):
    test = WasRun("testMethod")
    result = TestResult()
    test.run(result)
    assert("setUp testMethod tearDown " == test.log)
```

**适用场景**：
- 实现观察者模式，期望通知按特定顺序到达
- 如果不关心顺序，可以维护字符串集并使用集合比较

## 破坏测试（Broken Test）

> "独自编程时如何离开编程会话？让最后一个测试失败。"

- 类似作家写到句子中间停止
- 返回时有明显的起点
- 有具体书签帮助回忆思考状态
- 快速修复让你重回胜利之路

## 清洁签入（Clean Check-in）

> "团队编程时如何离开编程会话？让所有测试运行。"

- 总是在签入前确保所有测试运行
- 从确定性和信心开始
- 如果集成套件中有测试失败，考虑放弃工作重新开始
- **禁止**注释掉测试以使套件通过

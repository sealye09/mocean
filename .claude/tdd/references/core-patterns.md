# TDD 核心模式

## 测试模式

> "如何测试软件？编写自动化测试。"

自动化测试打破了压力反馈循环：
- **无自动化**：压力 → 更少测试 → 更多错误 → 更多压力
- **有自动化**：压力 → 更多测试 → 更少错误 → 更少压力

## 隔离测试

> "测试之间应该如何相互影响？完全没有。"

**规则**：
- 测试必须与执行顺序无关
- 一个失败的测试 = 一个问题
- 测试之间不共享状态

**收益**：
- 强制高内聚、低耦合
- 可以轻松运行测试子集
- 测试失败时诊断清晰

## 测试列表

> "应该测试什么？开始前列出所有测试。"

**流程**：
1. 列出需要实现的每个操作
2. 为不存在的操作添加空版本
3. 列出预期的重构

**原因**：
- 每一步都知道脚落在哪里
- 防止"红条疲劳"（太多测试失败）
- 实现过程中发现新测试时添加到列表

## 测试先行

> "何时编写测试？在代码之前。"

**收益**：
- 设计工具——想象完美的API
- 范围控制——明确的完成标准
- 减轻压力——测试的良性循环

## 断言先行

> "何时编写断言？尝试先写断言。"

从断言开始，反向推导：
1. 正确答案是什么？
2. 如何检查？
3. 需要什么设置？

**示例**：
```python
# 从这里开始
assertTrue(reader.isClosed())
assertEquals("abc", reply.contents())

# 反向推导
Buffer reply = reader.contents()
Socket reader = Socket("localhost", defaultPort())
Server writer = Server(defaultPort(), "abc")
```

## 红/绿/重构

完整的TDD循环：

1. **红** - 添加测试，看它失败
2. **绿** - 让它通过（快速、简单）
3. **重构** - 消除重复

**关键**："TDD不是要用微小的步骤，而是有能力用微小的步骤。"

## 假装实现（Fake It）

遇到困难时，硬编码答案以获得绿条，然后泛化。

```javascript
// 从这里开始
amount = 10;

// 然后泛化
amount = 5 * 2;

// 然后参数化
amount = amount * multiplier;
```

这保持循环简短，反馈即时。

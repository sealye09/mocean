# TDD 中的设计模式

## 命令模式（Command）

> "如何表示请求？将请求封装为对象。"

**在xUnit中的应用**：
- `Test.run(TestResult)` 将测试执行封装为命令
- 支持测试的排队、组合和延迟执行
- 测试可以被存储、传递和调用

**结构**：
- 声明执行操作的接口
- 实现具体命令
- 调用者通过命令接口调用

## 组合模式（Composite）

> "如何表示对象层次结构？将对象组合成树形结构。"

**在xUnit中的应用**：
- `TestSuite` 和 `Test` 实现相同接口
- 可以递归地组合测试和套件
- 客户端统一处理单个和组合对象

**收益**：
- 轻松添加新类型的组件
- 简化客户端代码
- 支持任意复杂的测试结构

## 模板方法（Template Method）

> "如何定义算法骨架？在基类中定义，让子类实现步骤。"

**在xUnit中的应用**：
- `run()` 调用 `setUp()` → `runTest()` → `tearDown()`
- 框架定义执行顺序
- 子类提供具体实现

**变体**：插件方法
- 框架调用特定命名的用户方法
- 如 `setUp()`, `tearDown()`, `testXXX()`

## 观察者模式（Observer）

> "如何让对象在状态变化时通知其他对象？使用订阅/发布机制。"

**与TDD的关系**：
- 测试结果收集使用观察者
- `TestResult` 观察 `Test` 的执行
- 支持多个监听器（GUI、日志等）

## 自身分流（Self Shunt）

> "如何测试对象之间的协作？让测试用例实现接口。"

**方法**：
- 测试用例实现被测试对象需要的接口
- 将测试作为参数传递
- 验证交互是否正确

**示例**：
```java
class MyTest extends TestCase implements Listener {
    void testSomething() {
        subject.setListener(this);
        // ... 触发事件
    }

    void onEvent(Event e) {
        // 记录事件
    }
}
```

## 工厂方法（Factory Method）

> "如何让子类决定实例化哪个类？让子类创建对象。"

**在TDD中的应用**：
- `createResult()` 允许子类返回自定义的TestResult
- 支持扩展而不修改框架
- 测试可以创建特定的测试环境

## 适配器模式（Adapter）

> "如何使不兼容的接口协同工作？包装一个对象。"

**应用**：
- 使遗留代码可测试
- 创建测试替身（stub、mock）
- 桥接不同接口

## 策略模式（Strategy）

> "如何封装可互换的算法？定义接口，实现多个策略。"

**在TDD中**：
- 不同的断言策略
- 可插拔的测试运行器
- 多种测试结果格式化器

## 装饰器模式（Decorator）

> "如何动态添加职责？包装对象。"

**应用**：
- 为测试添加重试逻辑
- 添加超时功能
- 添加性能监控

## 元组（Tuple）

> "如何传递多个返回值？使用固定大小的集合。"

**在TDD中**：
- 测试数据组合
- 多值返回简化
- 临时数据结构

## 表格驱动测试（Table Driven Testing）

> "如何用多种输入测试同一逻辑？使用数据表。"

**方法**：
- 定义输入/预期输出表
- 迭代表格执行测试
- 减少重复测试代码

```java
Object[][] cases = {
    {5, 2, 10},
    {3, 4, 12},
    {0, 5, 0}
};
for (Object[] c : cases) {
    assertEquals(c[2], multiply((int)c[0], (int)c[1]));
}
```

## 空对象模式（Null Object）

> "如何处理空值？使用无操作对象。"

**在测试中**：
- 提供安全的默认实现
- 简化测试设置
- 避免null检查

## 代理模式（Proxy）

> "如何控制对对象的访问？使用代理对象。"

**测试应用**：
- 延迟加载测试资源
- 远程测试执行
- 访问控制测试

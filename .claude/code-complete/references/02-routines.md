# 子程序设计

**基于《Code Complete 代码大全》第4-5章**

## 概述

子程序是计算机科学最重要的发明之一，使现代编程成为可能。本章讲述如何设计高质量的子程序。

## 创建子程序的步骤

### 标准流程

按照以下顺序创建子程序（不要跳过步骤）：

```
设计 → 编写 PDL → 编码 → 检查 → 测试
```

### 1. 设计子程序

**关键活动：**

#### a. 检查先决条件
- 子程序的任务是否明确定义？
- 是否与整体架构设计一致？
- 在项目需求中是否有涉及？

#### b. 定义问题
详细说明要解决的问题，包括：
- 隐藏的信息（状态）
- 输入
- 输出（包括受影响的全局变量）
- 错误处理策略

#### c. 命名子程序
- **原则**：名字应清楚、无歧义
- **警示**：如果难以命名，说明对功能理解不够清楚
- **示例**：
  - ✅ `RecordErrorMessage()` - 清楚
  - ❌ `HandleStuff()` - 模糊

#### d. 规划测试
在编写子程序时同时考虑如何测试
- 确定测试用例（有效和无效输入）
- 设计测试数据

#### e. 考虑效率
- **非关键路径**：优先模块化和可读性
- **性能关键**：在设计阶段确定速度和空间约束

### 2. 编写 PDL（程序设计语言）

**什么是 PDL？**
- 类似英语的伪代码
- 在"意图层次"描述操作
- 不使用特定编程语言的语法

**PDL 的优势：**
1. **简化评审**：可以在不检查源代码的情况下评审设计
2. **支持逐步细化**：从高层设计 → PDL → 代码
3. **易于修改**：改 PDL 比改代码容易得多
4. **减少注释工作**：PDL 本身就是注释
5. **易于维护**：设计和代码保持一致

**PDL 编写原则：**

✅ 好的 PDL 示例：
```
Keep track of current number of resource in use
If another resource is available
    Allocate a dialog box structure
    If a dialog box structure could be allocated
        Note that one more resource is in use
        Initialize the resource
        Store the resource number at the location provided by the caller
    Endif
Endif
Return TRUE if a new resource was created; else return FALSE
```

❌ 坏的 PDL 示例（太接近代码）：
```
Increment resource number by 1
allocate a dlg struct using malloc
if malloc() returns NULL then return 1
invoke OSrsrc_init to initialize a resource
*hRstcPtr = resource number
return 0
```

**关键区别：**
- 好的 PDL 描述"做什么"（意图）
- 坏的 PDL 描述"怎么做"（实现细节）

### 3. 编码

从 PDL 到代码的转换：
- 在每一行 PDL 下面填写对应的代码
- PDL 成为代码的注释
- 保持 PDL 的逻辑结构

### 4. 检查代码

**检查内容：**
- 是否实现了所有 PDL 描述的功能？
- 代码风格是否一致？
- 是否有防错性编程措施？
- 是否处理了边界情况？

## 高质量子程序的特征

### 1. 单一职责

**一个子程序应该只做一件事，并做好。**

❌ 反模式（多个职责）：
```pascal
Procedure HandleStuff(
    Var InputRec: CORP_DATA,
    CrntQtr: integer,
    EmpRec: EMP_DATA,
    Var EstimRevenue: Real,
    ...
)
begin
    for i := 1 to 100 do begin
        InputRec.revenue[i] := 0;           // 初始化
        InputRec.expense[i] := CorpExpense[...];  // 初始化
    end;
    UpdateCorpDatabase(EmpRec);             // 数据库操作
    EstimRevenue := YTDRevenue * 4.0 / real(CrntQtr);  // 计算
    // ...更多不相关的操作
end;
```

这个子程序的问题：
- 名称模糊（`HandleStuff`）
- 做了太多不相关的事情
- 修改了输入参数
- 读写全局变量
- 没有防错措施
- 参数太多（11个！）

### 2. 强内聚性

**内聚性类型（从好到坏）：**

1. **功能内聚**（最好）- 做且仅做一件事
2. **顺序内聚** - 步骤有逻辑顺序
3. **通信内聚** - 操作相同数据
4. **过程内聚** - 按执行顺序组织
5. **逻辑内聚** - 相关功能但可任选其一
6. **偶然内聚**（最差）- 无关联的操作

**目标**：追求功能内聚

### 3. 松散耦合性

**耦合类型（从低到高）：**

1. **简单数据耦合**（最好）- 通过参数传递简单数据
2. **数据结构耦合** - 传递数据结构
3. **控制耦合** - 传递控制标志
4. **外部耦合** - 都访问同一外部资源
5. **公共耦合**（最差）- 都访问全局数据

**降低耦合的方法：**
- 使用参数而不是全局变量
- 避免修改输入参数
- 最小化参数数量（建议 ≤ 7个）
- 使用参数对象封装相关参数

### 4. 合理长度

**长度指南：**
- **理想**：屏幕内可见（约 20-50 行）
- **上限**：不超过一屏（约 100 行）
- **关键**：长度是复杂性的指标，不是目标

**如果子程序太长，考虑：**
- 是否做了太多事情？
- 是否可以提取子子程序？
- 是否有重复代码可以提取？

### 5. 好的命名

**命名原则：**
- **动词-名词对**：描述操作
- **准确具体**：避免模糊词汇
- **一致性**：项目中使用相同的命名约定

**示例：**

| 好的命名 | 坏的命名 | 原因 |
|---------|---------|------|
| `calculateTotal()` | `doIt()` | 不具体 |
| `isValidUserId()` | `check()` | 检查什么？ |
| `printReport()` | `processData()` | 模糊 |
| `getUserById()` | `getStuff()` | 不专业 |

### 6. 防错性编程

**原则：始终防御性地编写代码**

**实践：**
- 验证输入参数
- 处理边界情况
- 断言假设
- 使用断言检查不变量
- 处理错误返回值

**示例：**
```javascript
// ❌ 不安全
function divide(a, b) {
  return a / b;  // 如果 b = 0 会怎样？
}

// ✅ 安全
function divide(a, b) {
  if (b === 0) {
    throw new Error("Division by zero");
  }
  return a / b;
}
```

### 7. 良好的参数设计

**参数设计原则：**

1. **数量控制**：≤ 7 个参数
   - 如果更多，考虑：
     - 封装成参数对象
     - 分拆成多个子程序

2. **输入/输出明确**：
   - **输入参数**：不应被修改
   - **输出参数**：清楚标识
   - **输入输出参数**：谨慎使用

3. **参数顺序**：
   - 输入 → 输入输出 → 输出
   - 最重要 → 次重要

4. **避免参数滥用**：
   - ❌ `function(data, flag1, flag2, flag3, mode, option)`
   - ✅ 使用参数对象或配置对象

## 何时创建子程序

### ✅ 创建子程序的正当理由

1. **降低复杂性**
   - 隐藏实现细节
   - 减少认知负担
   - 提高可读性

2. **避免重复代码**
   - 相同代码出现 ≥ 2 次
   - 提取为独立子程序

3. **限制改动影响**
   - 隔离可能变化的代码
   - 便于后续修改

4. **隐藏顺序**
   - 隐藏操作顺序的依赖
   - 提高灵活性

5. **改进性能**
   - 集中优化热点代码
   - 便于替换实现

6. **集中控制**
   - 统一管理资源访问
   - 统一错误处理

7. **隐藏数据结构**
   - 封装实现细节
   - 便于修改存储方式

### ❌ 不应创建子程序的情况

- 仅仅为了"看起来更高级"
- 代码只会使用一次且非常简单
- 导致代码更难理解（过度抽象）

## 实践检查清单

### 设计阶段

- [ ] 单一职责
- [ ] 名称清楚准确
- [ ] 输入/输出明确定义
- [ ] 考虑了错误处理
- [ ] 参数数量 ≤ 7 个

### 编码阶段

- [ ] 使用 PDL 进行设计
- [ ] PDL 描述"做什么"而非"怎么做"
- [ ] 代码遵循 PDL 结构
- [ ] PDL 成为注释

### 检查阶段

- [ ] 验证所有路径
- [ ] 检查边界情况
- [ ] 防错性编程措施
- [ ] 一致的代码风格

## 常见错误

1. **过度复杂**：一个子程序做太多事
   - **解决**：拆分成多个单一职责的子程序

2. **参数过多**：超过 7 个参数
   - **解决**：使用参数对象

3. **修改输入参数**：破坏调用者的数据
   - **解决**：明确标识输出参数，或返回新值

4. **全局变量依赖**：难以理解和测试
   - **解决**：通过参数传递

5. **魔法数字**：代码中出现未命名的常数
   - **解决**：使用命名常量

6. **缺少错误处理**：假设一切正常
   - **解决**：验证输入，处理错误

## 何时参考此内容

查阅此材料当：
- 设计新的函数/方法
- 重构现有代码
- 代码评审时评估子程序质量
- 感到代码过于复杂
- 不确定如何组织代码

## 相关阅读

- **模块化设计**：参见 `03-design.md`
- **数据相关**：参见 `04-data.md`
- **代码风格**：参见 `06-code-style.md`
# 编程哲学

**基于《Code Complete 代码大全》第31-33章**

## 概述

编程不仅是技术活动，更是艺术、科学和技艺的结合。本章涵盖程序员个人性格、软件开发方法和持续学习的重要性。

**核心观点**：软件工程的基本材料是人的聪明才智，主要工具是你自己。成为优秀程序员的关键在于个人性格、思维习惯和持续学习。

## 程序员的个人性格（第31章）

### 性格的重要性

**编程的特殊性**：
- 建筑师用木材、混凝土、钢材
- 软件工程师用人的智力
- 你的主要工具是你自己

**编程工作特点**：
- 极强的内部性，难以检查
- 老板无法判断你是否称职
- 80%时间用于20%感兴趣的工作
- 必须依靠自己下功夫

**个人差异的影响**：
- 程序创建时间：可达10:1
- 调试时间：可达10:1
- 程序长度：可达10:1
- 执行速度：可达10:1
- 错误率：可达10:1

**好消息**：你无法改变聪明程度，但可以在一定程度上改变性格。性格是成为高级程序员更具决定意义的因素。

### 聪明和谦虚

**关键洞察**：你利用聪明的程度比有多聪明更重要。

**Edsger Dijkstra的观点**：
- 论文《The Humble Programmer》（谦虚的程序员）
- 程序员应尽力弥补智力的局限性
- 最精通编程的人往往认为自己头脑有限
- 最糟糕的程序员拒绝承认能力不适应工作

**谦虚的实践**：

良好的编程风格旨在减少大脑负担：

1. **分解系统**
   - 将复杂问题分解为简单部分
   - 几条简单信息比一条复杂信息易理解
   - 所有设计方法目标相同

2. **评审、检查和测试**
   - 弥补人的错误
   - 知道能力有限，和别人讨论
   - "无错编程"部分源于评审方法

3. **编写短子程序**
   - 减少工作量
   - 根据问题而非计算机科学术语编程
   - 使用高级抽象思维

4. **使用交谈方式**
   - 从死胡同中解放出来
   - "交谈调试"常在3分钟内发现问题

**研究结果**：谦虚的程序员编写的程序更易理解，错误更少。

### 好奇心

**重要性**：技术信息变化迅速，每隔5-10年技术环境特征就发生变化。

**培养好奇心的方法**：

**1. 建立自我意识**
- 了解开发过程
- 理解各种修改
- 如果工作中不能学到东西，考虑换工作
- 美国计算机系统分析员预计增长53%（1988-2000）

**2. 实验**
- 编写短程序检查不熟悉的特征
- 在调试器中观察程序执行
- **最佳学习方法**：快速制造错误并从中学习
- 制造错误不是罪过，不从中学习才是罪过

**3. 阅读解决问题的方法**
- 人们通常不能自己发现解决问题的方法
- 即使方法很容易学到
- 不要重复发明车轮

**4. 在行动前分析和计划**
- 问题不在过分分析
- 而在过分行动
- 大多数程序员的问题是分析和行动不够

**5. 学习成功项目**
- Jon Bentley：如同读小说一样阅读程序
- 研究高级程序的设计
- 有选择地研究具体细节
- 学习成功和失败的例子

**6. 阅读他人代码**
- 阅读尊敬的程序员的代码
- 阅读不喜欢的程序员的代码
- 比较异同，分析原因
- 让高水平程序员评价你的代码

**7. 阅读手册**
- 手册恐惧症很流行，但错误
- 手册含有重要信息
- 现代语言有大量程序库
- 定期查阅参考手册

**8. 阅读书籍和期刊**
- 每两月阅读一本好的计算机书籍
- 将在同行中脱颖而出
- 持续学习是关键

### 诚实

**编程成熟的标志**：不折不挠地坚持诚实。

**诚实的表现**：

1. **不假装是编程能手**
   - 假装知之甚少，听别人解释
   - 向他们学习新东西
   - 评估他们是否真正了解

2. **乐于承认错误**
   - 拒绝承认错误令人讨厌
   - 所有人都知道你犯了错误
   - 迅速主动地承认错误

3. **理解编译器警告**
   - 不要置之不理
   - 编译器将问题明白展示
   - 忽视警告浪费时间

4. **对程序有清晰了解**
   - 不要"编译看是否能运行"
   - 测试只能发现错误存在
   - 不能保证没有错误
   - 编译前应有深刻理解

5. **提供实际状态报告**
   - "90%完成"不可信
   - 应对工作加强了解
   - 上司愿意听真实报告

6. **提供实际评估**
   - **关键原则**：评估是不可商量的
   - 不能和老板"商量"项目时间
   - 就像不能商量一里有多少英尺
   - 可以商定影响进度的各方面：
     - 减少特征
     - 降低性能
     - 分阶段开发
     - 调整人员和时间的平衡

**坚持评估**：
- IBM的Bill Weimer：技术人员能准确估计
- 问题在于能否坚持自己的决定
- 妥协失去信任，坚持得到尊敬

### 交流和合作

**核心观点**：编程首先和程序员交流，其次才是计算机。

**可读性原则**：将修改代码的人时刻记在心上。

**程序员级别**：

**级别1：初学者**
- 能使用语言基本能力
- 使用子程序、循环、条件语句

**级别2：中间者**
- 使用多种语言
- 至少非常熟悉某一种语言

**级别3：专家**
- 对语言或环境有很深造诣
- 对公司有价值
- 有些人停留在这个水平

**级别4：大师**
- 有专家的专业知识
- 意识到编程只是15%和计算机交流
- 其余85%和人打交道
- 代码为人编写，其次为计算机
- 建立完整文档
- 不浪费精力重建用注释能说清楚的逻辑

**不可读代码的原因**：
- 不是故意使代码难懂
- 而是不能完整理解自己的代码
- 只能停留在1或2级水平

**目标**：不必为初学者或专家内疚，应为自己停留在某个水平太久而内疚。知道如何提高后，就应提高。

### 创造力和纪律

**现实检验**：
- 学校：最好的程序员
- Real World：阅读理解200,000行Fortran程序
- 500行实用工具 vs 50万行项目

**大项目需要纪律**：
- 没有标准和约定，项目无法实现
- 不可能发挥创造性
- 在不重要领域建立约定
- 在值得的地方集中发挥创造力

**NASA研究**：
- 强调纪律的方法和工具非常有效
- 高创造力的人能很好遵守纪律

**艺术中的纪律**：
- 建筑师在材料性能、时间、代价限定内工作
- Leonardo da Vinci在细节上遵守约定
- 米开朗琪罗使用均衡几何形式
- 没有自我约束和结构，300人物排列混乱

**程序员的教训**：
- 编码前不分析需求就设计 → 学习不到东西
- 结果像三岁小孩的手指画，不是艺术作品

### 懒惰

**懒惰的形式**：

**1. 拖延（真懒惰）**
- 拖延讨厌的工作
- 编译子程序检查情况避免人工检查
- 浪费时间做不必要工作

**2. 迅速完成（明懒惰）**
- 迅速完成讨厌任务以摆脱
- 马上完成任务克服拖延
- 仍是懒惰，但尽量少花时间

**3. 编写工具（长期懒惰）**
- 编写工具完成讨厌工作
- 编写工具最终节省时间
- **最有积极性的懒惰形式**

**关于"赶着做"**：
- "赶着做"不是努力，是焦急
- 编程中最重要的现象：思考时不忙
- 看起来一直很忙的程序员不是好程序员
- 没有使用最有价值的工具——大脑

### 其他性格

**坚持（可能是好事或坏事）**：
- 好的定义：坚强
- 坏的定义：顽固
- 软件开发中：坚持≈顽固
- 调试15分钟无进展 → 放弃
- 用潜意识思考，尝试别的方法

**经验**：
- 软件开发中经验价值比其他领域小
- 知识发展迅速
- 老程序员对新基本概念缺乏了解
- 不改变思维方式，经验不值一文
- 老的准备上一次战斗，不是下一次
- 人们从经验中得出错误结论
- "五年经验"：前两年最重要，后三年区别不大
- 10年经验应该是真正的经验，坚持学习

**计算机迷**：
- 通宵编程令人兴奋
- 但几乎注定要失败
- 花费几周修正通宵带来的错误
- 可以热爱编程，但要冷静处理

### 习惯

**习惯的力量**：
- 大部分事情在无意识中完成
- 格式化时不再思考
- 最后一次质疑在几年前
- 剩下的时间受习惯支配

**习惯的例子**：
- 仔细检查循环变量，少检查赋值语句
- 对批评的反应（友好或不友好）
- 可读性 vs 编码速度的选择
- 不是真正选择，是习惯性反应

**Bill Gates的观点**：
- 任何好程序员在开始的几年都做得很好
- 从那以后，好坏基本定型
- 长时间后很难突然问"我怎样才能更好？"
- 好程序员一开始就养成的习惯

**养成好习惯**：
- 开始学习时按正确方式学好
- 可在正确或错误途径间轻易选择
- 一段时间后，不太注意所作
- "习惯的力量"开始起作用
- 确保起作用的习惯是你希望的

**改变习惯**：
- 不能用没有习惯取代坏习惯
- 像戒烟或节食，很难
- 用新习惯代替旧习惯更容易
- 养成好习惯，坏习惯自然消失
- 例如：编码前写PDL，编译前阅读代码

## 软件开发方法（第32章）

### 克服复杂性

**挑战的规模**：
- 计算是唯一用1比特到几百兆比特度量的领域
- 比率可达1:10^9
- Edsger Dijkstra：一般数学方法无能为力

**计算机科学的核心**：减少复杂性

**减少复杂性的方法**：

**结构级**：
- 将系统分成子系统
- 子程序越独立，复杂性越低
- 仔细定义模块
- 一次集中于一件事情

**数据管理**：
- 全局数据削弱集中能力
- 使用模块数据无害
- 避免全局变量共享或粗糙定义的接口

**代码质量**：
- 好的设计最大程度降低复杂性
- 限制控制结构（if, for）
- 使用无循环代码
- 避免goto（不遵循特定模式）
- 编写短子程序
- 限制循环嵌套和if语句
- 限制变量数

**抽象化**：
- 布尔函数抽象化测试目的
- 查询表代替复杂逻辑链
- 数据结构具体实现细节

**编码约定**：
- 标准化程序格式
- 循环方式
- 变量命名
- 省下精力处理更富挑战性的问题

**层次结构**：
- 使用层次对大部分人很自然
- 画房子：轮廓→窗户门→细节
- 不是一块砖一块瓦画
- 递升层次：
  0. 机器指令
  1. 操作系统运行
  2. 高级语言编程
  3. 用户接口操作
- 创建自己的层次

**抽象和复杂**：
- 抽象比层次更一般
- 通过在各部分间分布细节降低复杂性
- "房子"而非玻璃、木材、钉子
- "小镇"而非许多房子

**抽象的例子**：
- 机器语言→高级语言（最大进步）
- 子程序使用
- DBMS（抽象数据）
- 按作用命名变量（What not How）
- 命名常量
- 抽象数据类型
- 面向对象（算法和数据同时抽象）

**核心目标**：软件设计和编码的主要目标是克服复杂性。

### 精选开发过程

**主要观点**：软件开发与相应过程有很大关系。

**小项目**：
- 程序员才能对质量影响最大
- 过程选择有一定影响

**多程序员项目**：
- 整个组织特征比单个程序员技能更起作用
- 集体能力不是个人力量简单相加
- 人们一起工作的方式决定集体力量
- 工作过程决定影响是有益还是阻碍

**过程起作用的例子**：

**1. 需求稳定性**
- 不知道创建什么 → 不能得到好设计
- 需求修改 → 代码修改 → 系统质量降低
- 过程决定需求稳定性
- 分阶段交付提供灵活性

**2. 设计基础**
- 开始建造前应有牢固基础
- 创建完成前急着编码 → 重大修改困难
- 人们感情投资，继续为自己设计辩护
- 像改变已建房子的基底

**3. 质量控制**
- 从一开始就控制质量
- 不能随心所欲编码，然后测试
- 测试仅告诉你错误存在
- 不能使程序更有用、更快、更短、更可读

**4. 不成熟的乐观**
- 有效开发：粗糙调整→好的调查
- 雕刻师：先雕刻轮廓，后修饰细节
- 不成熟乐观：修饰不必修饰的代码
- 常问："改变顺序会产生差别？"

**5. 低级过程**
- 使用PDL流程图
- 围绕PDL设计代码
- 自顶向下设计
- 及时注释

**关键**：停下来留神如何创建软件，这是值得花费时间的。

### 首先为人编写程序，其次才是计算机

**可读性的影响**：
- 可理解性
- 可检查性
- 错误率
- 调试
- 可修改性
- 开发时间
- 外部质量

**早期观点**：
- 程序是程序员私人财产
- 查看程序如同私拆情书
- 程序是程序员给硬件写的情书
- 亲密细节只有当事者清楚

**现实**：
- 编写可读代码并不费时
- 最终对你有益
- 评审、改错、利用代码都需要读
- 应力争一次编写好代码

**"我的代码自己用"**：
- 一两周后需要看自己代码
- 如果不可读，够受的
- 如项目中的Lone Ranger，令人厌烦

**Douglas Comer区分**：
- **私人程序**：自己使用，琐碎，不为他人使用
- **公用程序**：他人使用和修改，应仔细编写
- 转换成公用程序前注意可读性

**研究数据**：
- 维护程序员重写前需研究程序10次
- 花费50%-60%时间理解代码
- 真希望有文档工作

**可读性方法**：
- 好的变量名
- 良好的格式
- 好的子程序名
- 小的子程序
- 布尔函数隐含复杂测试
- 中间变量
- 没有简单方法得出可读性差别

### 注重约定使用

**约定的价值**：
- 复杂性管理的有效工具
- 反复使用相同的武断决定

**约定的好处**：

**1. 精确传递信息**
- 命名约定：单一字符区分类型
- 大小写区分变量类型
- 缩进显示逻辑结构
- 对齐表明相关语句

**2. 防止危害**
- 禁止全局变量
- 一行多语句
- 限制goto只转到子程序末尾
- 要求复杂表达式使用括号
- 指针释放后马上清除

**3. 提高预测性**
- 存储器请求
- 错误处理
- 输入/输出
- 子程序接口
- 使代码结构良好，易于理解

**4. 弥补语言不足**
- 不支持命名常量 → 约定区分
- 限制goto和指针使用

**大项目 vs 小项目**：
- 大项目：似乎使用过分
- 小项目：使用不够
- 应了解真正价值并正确利用

### 根据问题范围编程

**处理复杂性的特定方法**：在最高可能的抽象级上工作。

**高级代码不应充满**：
- 文件、堆栈、队列、数组细节
- i、j、k等变量
- 打开文件等细节
- "i在此处代表雇员，以后代表顾客"注释

**笨拙的编程**：
- 顶层无需知道雇员数据来源
- 高级信息应隐含
- 不应需要解释i的注释
- 应有两个不同变量：EmployeeIdx和ClientIdx

**抽象级别**：

**第0级：操作系统操作和机器指令**

**第1级：高级语言结构**
- 原始数据类型
- 控制结构
- 使用很自然
- 许多程序员从不在此级之上工作

**第2级：计算机科学结构**
- 稍高一级
- 堆栈、队列、链表、树
- 索引文件、顺序文件
- 排序法、搜索算法
- 仍有细节工作要做

**第3级：低级问题领域**
- 问题的原始描述
- 清楚专业术语和积木块
- 子程序不能直接解决问题
- 生成更高级的子程序

**第4级：高级问题领域**
- 提供抽象能力
- 代码可读，一般应用人员可懂
- 不完全依赖语言特征
- 依赖创建的工具
- 细节隐藏在两层外壳下
- 包含用户见解

**在问题领域采用低级方法**：
- 使用抽象数据类型实现有意义结构
- 隐含计算机结构和实现细节
- 面向对象：设计和问题直接相关的成员
- 对有意义的字符串和数字使用命名常量
- 对中间计算使用中间变量
- 使用布尔函数净化复杂测试

### 当心飞来之祸

**编程是技艺**：
- 不是完全艺术或科学
- 需要大量个人判断
- 好的判断需要警告信息反应

**"这真是一个棘手的程序"**：
- 警告信号
- "棘手"≈"坏"
- 考虑重写

**其他警告信号**：
- 比一般子程序含更多错误
- 出现反常错误数
- 程序编制让人难以理解
- 不通过阅读来理解代码
- 编写注释、命名变量、分解问题困难
- 老是编制相同代码或作相似修改
- 难以创建测试事例骨架
- 子程序缺乏独立性

**警告的用途**：
- 怀疑使我们不舒服和不满意
- 视为"怀疑的激励"
- 促使追求更完美境界
- 意味着设计不是很好

**创建自己的错误警告**：
- 即使知道警告也易忽视
- 未发现错误最常见原因：忽视
- 释放指针后置为NULL
- 编译警告也是文字警告
- 仔细程度决定程序质量

### 重复

**合适的重复**：
- 和用户商量需求形式
- 分阶段交付系统
- 迅速廉价开发几种不同方法
- 初始阶段重复最重要

**进度评估**：
- 不同方法评估结果差别很大
- 重复方法比单一方法更精确

**软件设计**：
- 经过逐步修改和提高
- 被确证有效，不是被证明
- 重复测试和开发直到正确
- 高级和低级设计都应重复
- 第一次尝试可行，但不一定是最好

**代码调整**：
- 重复有益
- 重写小部分提高性能
- 有些优化只会降低性能
- 不是凭直觉的过程
- 反复调整和度量
- 最后几次尝试可能更成功

**评审**：
- 使开发过程少走弯路
- 任何阶段都可插入重复
- 产品未通过 → 返工
- 产品通过 → 不需重复

**避免极端**：
- 创建将废弃不用的东西
- Fred Brook：用1美元完成别人2美元的事
- 废弃整个系统是用2美元完成别人1美元的事
- 尽可能迅速处理要报废的事

### 不要固执己见

**偏执的变种**：
- 顽固坚持某种设计方法
- 执着于特定格式或注释风格
- 一味不用goto

**判断**：
- 优秀人员更容易偏执
- 新方法应充分证实
- 技术转移很重要
- 不是卖狗皮膏药

**识别卖狗皮膏**：
- 极力鼓吹方法灵验
- 要你忘掉过去所学
- 声称提高效率100%
- 询问使用新方法多久
- "使用15年"≠亲自使用
- 询问亲自使用多久
- 可能既没用新方法也没用旧方法开发过系统

**不要充耳不闻**：
- 取长补短
- 保留原来好的

**选择**：
- 盲目迷信阻碍有效解答
- 软件开发靠经验
- 僵化过程不合适
- 有时自顶向下有效
- 有时面向对象、自底向上、数据结构有效
- 应有尝试几种途径的愿望
- 将方法视为工具盒中的工具

**工程学**：
- 对各种方法综合评估
- 限制在单一工具 → 无法衡量
- 工具箱比喻有用的原因
- 在大部分时间选择无关紧要
- 有些场合选择重要

**实验**：
- 选择和实验密切联系
- 整个开发过程坚持实验
- 偏执可能阻止实验
- 需要随机应变
- 避免发生错误是最大的错误
- 设计是计划小错误避免大错误
- 实验是创建测试的过程

**各级实验**：
- 结构设计级：不同方法勾画结构
- 细节设计级：不同低级设计方法
- 编程语言级：编写短程序检查功能
- 代码调整级：调试并度量
- 质量和效率：收集数据

**关键**：
- 对各方面保持开放思想
- 开发过程中学到技术
- 开发性实验和顽固坚持不相容

## 持续学习（第33章）

### 软件领域的资料库

**资料类型**：
- 解释有效编程基本概念的书
- 技术管理、知识背景的书
- 语言、操作系统、环境、硬件参考书
- 主要软件开发活动书籍（分析、设计、创建、管理、测试）

### 作者推荐的10种书

1. **The Psychology of Computer Programming** (1971)
   - Gerald Weinberg
   - 程序开发趣闻轶事

2. **Programming Pearls** (1986)
   - Jon Bentley
   - 生动有趣的程序讲解

3. **Classics in Software Engineering** (1979)
   - Ed Yourdon
   - 软件工程研究论文集

4. **Principles of Software Engineering Management** (1988)
   - Tom Gilb
   - 项目管理

5. **Structured Design** (1979)
   - Yourdon & Constantine
   - 结构设计方法和思想

6. **The Art of Software Testing** (1979)
   - Glenford Myers

7. **一本关于需求分析的书**

8. **一本关于项目计划和效率分析的书**

9. **一本关于数据结构和算法分析的书**

10. **一本从整体讨论软件开发过程的书**

### 软件创建信息

**相关书籍**：
- **Software Implementation** (1991)
  - Michael Marcotty
  - 侧重抽象、复杂性、可读性和修改
- **Practical Software Engineering**
  - Prentice Hall

### 创建之外的主题

**软件工程一般书籍**：
1. **Classics in Software Engineering** (1979), Ed Yourdon
2. **Writings of the Revolution** (1982), Ed Yourdon
3. **Tutorial: Programming Productivity** (1986), Capers Jones
4. **Software Conflict** (1991), Robert L. Glass

**软件工程总览**：
1. **Software Engineering** (1989), Ian Sommerville
2. **Software Engineering: A Practitioner's Approach** (1987), Roger S. Pressman
3. **Practical Handbook for Software Development** (1985), N.D. Birrell & M.A. Ould
4. **Making Software Engineering Happen** (1988), Roger Pressman

**用户界面设计**：
1. **Designing the User Interface** (1987), Ben Shneiderman
2. **The Elements of Friendly Software Design** (1991), Paul Heckel
3. **The Art of Human-Computer Interface Design** (1990), Brenda Laurel
4. **The Psychology of Everyday Things** (1988), Donald A. Norman

**数据库设计**：
1. **An Introduction to Database Systems** (1977), Chris Date
2. **Fundamentals of Database Systems** (1989), Ramez Elmasri & Shamkant B. Navathe

**正规方法**：
1. **Software Engineering Mathematics** (1988), Jim Woodcock & Martin Loomes
2. **Structured Programming: Theory and Practice** (1979), Richard C. Linger et al.
3. **Social Process and Proofs of Theorems and Programs** (1979), DeMillo et al.
4. **Program Verification: The Very Idea** (1988), James H. Fetzer

### 期刊

**初级程序员杂志**（本地书报摊）：
- BYTE
- Computer Language
- Datamation
- Dr. Dobb's Journal

**高级程序员杂志**（大学图书馆）：
- IEEE Software
- IEEE Computer
- Communications of the ACM

**精装出版物**：
- American Programmer
- The Software Practitioner
- Software Practice and Experience

**专题出版物**：
- The C Users Journal
- DBMS
- Embedded Systems Programming
- LAN Technology
- MacWorld
- PC Techniques
- UNIX Review
- Software Management News
- Windows Tech Journal

### 参加专业组织

**最佳学习方法**：和其它程序员接触和交流。

**可加入的组织**：
- 本地相关组织
- ACM（Association for Computing Machinery）
- IEEE（Institute of Electrical and Electronics Engineers）

## 编程哲学检查清单

### 个人性格

- [ ] 是否认识到谦虚的重要性？
- [ ] 是否承认智力的局限性？
- [ ] 是否使用评审和检查弥补错误？
- [ ] 是否保持好奇心？
- [ ] 是否持续学习新技术？
- [ ] 是否进行实验？
- [ ] 是否阅读他人的代码？
- [ ] 是否诚实面对错误？
- [ ] 是否承认不知道的事情？
- [ ] 是否理解编译器警告？
- [ ] 是否在编译前理解程序？
- [ ] 是否提供真实的状态报告？
- [ ] 是否坚持准确的评估？
- [ ] 是否编写可读代码？
- [ ] 是否为他人编写代码？
- [ ] 是否遵守约定和纪律？
- [ ] 是否发挥创造力？
- [ ] 是否编写工具提高效率？
- [ ] 是否养成好习惯？
- [ ] 是否反思自己的习惯？

### 开发方法

- [ ] 是否努力降低复杂性？
- [ ] 是否使用层次和抽象？
- [ ] 是否精选开发过程？
- [ ] 是否在编码前稳定需求？
- [ ] 是否在设计前有牢固基础？
- [ ] 是否从一开始控制质量？
- [ ] 是否为人编写程序，其次为计算机？
- [ ] 是否使用约定？
- [ ] 是否在问题范围编程？
- [ ] 是否注意警告信号？
- [ ] 是否进行重复和迭代？
- [ ] 是否固执于某种方法？
- [ ] 是否保持开放思想？
- [ ] 是否进行实验？

### 持续学习

- [ ] 是否阅读技术书籍？
- [ ] 是否阅读期刊杂志？
- [ ] 是否参加专业组织？
- [ ] 是否和同行交流？
- [ ] 是否建立参考资料库？
- [ ] 是否关注新技术？
- [ ] 是否学习成功和失败的例子？

## 常见错误

### ❌ 不要

1. **傲慢**
   - 认为自己什么都懂
   - 拒绝承认错误
   - 忽视他人建议

2. **缺乏好奇心**
   - 不学习新技术
   - 不实验
   - 不读他人代码

3. **不诚实**
   - 假装知道
   - 隐瞒错误
   - 提供虚假报告
   - 妥协评估

4. **编写不可读代码**
   - 只为自己编码
   - 不考虑他人
   - 滥用"聪明"技巧

5. **忽视约定**
   - 随意编码
   - 不遵循标准
   - 武断决定

6. **过早优化**
   - 不成熟的乐观
   - 在错误的地方下功夫
   - 编码前思考不足

7. **固执己见**
   - 坚持单一方法
   - 不尝试其他途径
   - 盲目相信时尚

8. **停止学习**
   - 不读书
   - 不交流
   - 不关注新技术

### ✅ 应该

1. **保持谦虚**
   - 承认局限性
   - 学习弥补方法
   - 使用评审和测试

2. **保持好奇心**
   - 持续学习
   - 进行实验
   - 阅读广泛

3. **保持诚实**
   - 承认错误
   - 提供真实报告
   - 坚持评估

4. **编写可读代码**
   - 为人编程
   - 使用约定
   - 建立文档

5. **精选过程**
   - 降低复杂性
   - 使用抽象
   - 重复迭代

6. **保持开放**
   - 尝试多种方法
   - 进行实验
   - 不固执

7. **持续学习**
   - 阅读书籍期刊
   - 参加组织
   - 与同行交流

8. **养成好习惯**
   - 反思习惯
   - 有意识改进
   - 用新习惯代替旧习惯

## 何时参考此内容

查阅此材料当：
- 提高个人编程素养
- 反思编程习惯
- 改进代码质量
- 选择开发方法
- 处理复杂性
- 建立团队约定
- 规划学习路径
- 寻找参考资料
- 参加专业社区
- 评估自己的编程水平

## 相关阅读

- **高质量程序**：参见 [05-statements.md](05-statements.md)
- **代码风格**：参见 [06-code-style.md](06-code-style.md)
- **质量保证**：参见 [07-quality.md](07-quality.md)
- **代码优化**：参见 [08-optimization.md](08-optimization.md)
- **子程序设计**：参见 [02-routines.md](02-routines.md)
- **模块化设计**：参见 [03-design.md](03-design.md)

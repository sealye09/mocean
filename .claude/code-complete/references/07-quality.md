# 质量保证

**基于《Code Complete 代码大全》第21-27章**

## 概述

软件质量保证（Quality Assurance, QA）是软件开发中至关重要的活动。本章涵盖项目规模对开发的影响、创建管理、质量保证方法、评审、测试、调试和系统集成等主题。

**核心观点**：提高质量可以减少开发时间和成本。软件开发中的质量原则——提高质量并减少各种花费。

## 项目规模对开发的影响（第21章）

### 项目规模的现实

**数据支持**：
- 50%的项目由1-3人开发
- 33%的项目由4-8人开发
- 只有约10%的项目有12人以上

**项目大小分类**：
- **小项目**：< 2K行代码
- **中等项目**：2K - 64K行代码
- **大项目**：64K - 512K行代码
- **超大项目**：> 512K行代码

### 规模对交流的影响

**交流途径爆炸**：
```
1人：0条交流途径
3人：3条交流途径
5人：10条交流途径
10人：45条交流途径
50人：1200+条交流途径
```

公式：交流途径数 = n × (n-1) / 2

**原则**：项目越大，越需要简化和规范化交流方式。

### 规模对开发活动的影响

随着项目增大，创建（编码、调试）所占比例减少：

| 项目规模 | 创建活动比例 |
|---------|------------|
| 小项目（<2K） | 约80% |
| 中等项目（2K-64K） | 约50% |
| 大项目（64K-512K） | 约30-40% |

其他活动比例相应增加：
- 计划、管理、需求开发
- 系统设计、接口设计
- 综合、系统测试、文档生成

**关键洞察**：
- 创建活动呈线性增长
- 其他活动呈乘幂增长
- 10倍大的项目可能需要12倍创建工作量和100倍计划工作量

### 规模对错误的影响

**错误密度随项目规模增加**：

| 项目规模 | 每1000行代码错误数 |
|---------|-------------------|
| < 2K | 0-25 |
| 2K-16K | 0-40 |
| 16K-64K | 0.5-50 |
| 64K-512K | 2-70 |
| > 512K | 4-100 |

**错误类型分布变化**：
- 小项目：75%为创建错误
- 大项目：创建错误占50%，分析和设计错误比例增加
- 超大项目（500K行）：75%以上是创建错误

### 规模对生产率的影响

**生产率随规模下降**：

| 项目规模 | 每月代码行数 |
|---------|------------|
| < 2K | 333-2000 |
| 2K-16K | 200-1250 |
| 16K-64K | 125-1000 |
| 64K-512K | 67-500 |
| > 512K | 36-250 |

**关键结论**：
- 最小项目的生产率是最大项目的10倍
- 从小项目（1K）到中等项目（9K）可能降低一半生产率

### 程序、产品、系统、系统产品

**复杂度递增**：

1. **程序**：用户自行开发的单一程序
2. **产品**：为他人使用，开发代价是程序的3倍
3. **系统**：多人协作开发，代价是程序的3倍
4. **系统产品**：系统+产品外壳，代价是程序的9倍

**常见估计错误**：
- 程序员常基于2K代码经验估计32K项目 → 估计仅为实际需要的50%

## 创建管理（第22章）

### 使用好的代码

**避免教条标准**，采用以下方法：

1. **结对编程**
   - 每部分代码至少2人负责
   - 确保至少2人认为代码能正常运行

2. **代码注释（阅读）**
   - 程序员+至少2个注释者
   - 至少3人阅读代码每一行
   - 利用"同级压力"提高质量

3. **代码签准**
   - 高级技术主管签署代码
   - 确保技术可行性

4. **展示好的示例**
   - 公开张贴优秀代码
   - 在代码标准手册中包含"最好的代码表"

5. **代码是公共财产**
   - 代码是计划的一部分
   - 评审和维护阶段应被他人看到

**成功案例**：
- 11人年、83,000行代码，运行13个月仅发现1个系统错误
- 关键：明确所有运算是公共的而非个人的

### 配置管理（SCM）

**定义**：全面处理各种变化，保证系统完整性。

**重要性**：
- 无控制的修改 → 编码和设计不一致
- 测试失败 → 无法回到正常工作状态

**组成部分**：

#### 1. 设计修改控制

**准则**：
- 遵循正规修改控制流程
- 建立修改控制委员会
- 集成考虑修改请求（不要只做容易的）
- 估计改变代价（包括测试和文档）
- 谨慎对待主要修改（可能表示需求分析不充分）

#### 2. 源代码控制

**版本控制软件的好处**：
- 避免多人同时修改冲突
- 轻松升级所有文件
- 回溯任何版本
- 获得修改历史
- 自动备份

**Make工具**：
- 减少生成目标文件时间
- 自动检测依赖关系
- 只编译受影响的文件

#### 3. 备份计划

**最佳实践**：
- 定期备份
- 移至安全地点
- 包括源代码、文档、图形、注释
- **测试备份恢复过程**

### 评估创建计划

**评估方法**：
1. 使用进度软件
2. 使用算法模型（如COCOMO）
3. 专家评估
4. 预评估会议
5. 分部分评估再集成
6. 自评+集成
7. 总时间细分到部分
8. 参考以前项目
9. 保存评估数据，调整未来评估

**评估原则**：
- 充足时间计划评估
- 定义需求后再估计
- 从细节层次评估
- 使用不同方法比较结果
- 定期再评估

**创建工作量分配**：

| 项目大小 | 详细设计 | 编码和调试 | 单元测试 |
|---------|---------|----------|---------|
| 小（<2K） | 10% | 65% | 25% |
| 中（8K-32K） | 15% | 55% | 30% |
| 大（>128K） | 20% | 45% | 35% |

**如果落后怎么办**：

❌ **不要**：
- 盲目努力追赶（只会越来越落后）
- 增加人数（会使项目更落后！）
  - 新手需要培训时间
  - 增加通信量
  - 布鲁克斯法则：9个月不能生1个孩子，9个女人1个月也不能生1个孩子

✅ **应该**：
- 减少项目范围（剔除"有更好"和"可选项"功能）
- 削减某些特征
- 降低性能要求
- 放松时间/空间需求

### 度量

**定义**：和软件开发有关的衡量。

**有用的度量**：

**长度度量**：
- 代码总行数
- 注释总行数
- 数据说明语句数
- 空行总数

**质量度量**：
- 总错误数
- 每个子程序错误数
- 每1000行代码错误数
- 失效平均时间

**生产率度量**：
- 总项目时间
- 每个人时间
- 项目费用
- 每行源代码费用

**维护性度量**：
- 每个子程序参数数
- 每个子程序局部变量数
- 控制流复杂性

**错误跟踪**：
- 每个错误严重程度
- 错误位置
- 纠正方法
- 纠正时间
- 纠正引起的错误数

**度量原则**：
- 从简单度量开始（错误数、时间、费用、代码行数）
- 有目的收集数据
- 定义度量目标
- 逐步精化度量标准

### 将程序员视为普通人

**时间分配**（贝尔实验室研究）：
- 35%：编程（源代码）
- 29%：事务处理
- 13%：私事
- 7%：开会
- 6%：培训
- 5%：邮件
- 2%：技术手册
- 3%：其他

**能力差别**：
- 最好/最差程序员编码时间比：20:1
- 调试时间比：25:1
- 程序长度比：5:1
- 执行速度比：10:1
- 工作经验与质量/效率无必然联系

**组间差别**：
- 好程序员趋向聚集
- 不同组工作量比可达3.4:1
- 80%贡献来自20%人员

**个人风格问题**：
程序员对以下因素敏感：
- goto语句使用
- 编程语言选择
- 缩进风格
- 大括号使用
- 文本编辑器选择
- 注释风格
- 效率vs可靠性权衡
- 方法选用
- 变量命名习惯

**物理环境影响**：
最好的25%程序员 vs 最差的25%：
- 未用空间：78 vs 46平方英尺
- 可接受环境：57% vs 29%
- 不受打扰：52% vs 10%（电话）
- 不受来客打扰：76% vs 19%

**生产率差异**：最好25%比最差25%效率高2.6倍

**投资回报**：
- 投资$10,000-$30,000/人改善环境
- 回报：39%-47%生产率增长
- 从最差25%提升到最好25% → 100%生产率增长

## 软件质量概述（第23章）

### 质量特征

**外部特征**（用户关心的）：
- **正确性**：受错误影响程度
- **可用性**：学习和使用难易度
- **效率**：资源利用（存储、时间）
- **可靠性**：执行特定功能能力
- **完整性**：防止非法访问
- **适应性**：在不同环境使用能力
- **精确性**：不受错误影响程度
- **坚固性**：在无效输入或压力下继续执行能力

**内部特征**（程序员关心的）：
- **可维护性**：修改和改进能力
- **灵活性**：适应不同用途能力
- **可移植性**：在不同环境运行能力
- **可重用性**：用于其他系统难易度
- **可读性**：理解源代码能力
- **可测试性**：测试难易度
- **可理解性**：从系统水平理解能力

### 质量保证方法

**质量管理计划组成部分**：

1. **质量管理目标**
   - 从特征中明确目标
   - 让程序员明白质量第一

2. **确定质量保证活动**
   - 独立质量保证活动
   - 程序员意识到质量重要性

3. **测试策略**
   - 执行时间估计可靠性

4. **软件工程准则**
   - 控制技术特性
   - 应用于开发各阶段

5. **非正式技术检查**
   - 手工检查设计、代码

6. **正规技术检查**
   - "质量门"（Quality Gate）
   - 定期检查确定是否满足继续下一步要求

7. **外部检查**
   - 检查组来自外部
   - 确定项目状态或质量

8. **修改控制过程**
   - 有效处理变化

9. **结果的定量**
   - 度量计划成功或失败
   - 人们习惯着重被度量的工作

10. **原型**
    - 可实现模块开发
    - 更好的设计、满足用户需求、提高可维护性

### 设置目标

**Weinberg-Schulman研究**：

5组程序员，不同质量目标：
- 最少存储
- 输出可读性
- 程序可读性
- 最少语句
- 最小编程时间

**结果**：4个组最先完成了被优化的目标！

**结论**：
- 程序员会按要求去做
- 但必须知道目标
- 目标间常相互冲突，不可能满足所有

### 方法的效果

**错误发现百分比**：

| 方法 | 最低比 | 中等比 | 最高比 |
|-----|--------|--------|--------|
| 设计文件人工检查 | 15% | 35% | 70% |
| 非正式组内设计检查 | 30% | 40% | 60% |
| 正式设计检查 | 35% | 55% | 75% |
| 正式代码检查 | 30% | 60% | 70% |
| 模型或原型 | 35% | 65% | 80% |
| 人工代码检查 | 20% | 40% | 60% |
| 单元测试 | 10% | 25% | 50% |
| 功能测试 | 20% | 35% | 55% |
| 系统测试 | 25% | 45% | 60% |
| 集成测试 | 93% | 99% | 99% |

**关键洞察**：
- 任何单一方法中等比不超过65%
- 必须集成应用几种方法
- 两种不同方法组合 → 发现错误数提高近2倍

### 发现/修改错误的代价

**发现错误代价**：
- 检查比测试更经济
- 有经验者：检查比测试多发现80%错误/小时

**修改错误代价**：
- 错误留在系统中时间越长，代价越大
- 一步方法（检查）vs 二步方法（测试）
- 微软：检查3小时vs调试12小时发现改正错误

**有效质量程序必须包括**：
- 系统关键部分的正式设计检查
- 快速原型化技术
- 代码阅读或检查
- 运行测试

### 软件质量的一般原则

**原则**：提高质量并减少各种花费。

**减少调试时间**：
- 传统开发：调试占50%时间
- 消除调试 → 提高生产率
- 缩短开发时间最明显方法：提高产品质量

**数据支持**：
- NASA：改进质量保证→降低错误，但总费用不降低
- IBM：从开始着眼最高质量→最好进度、最高生产率、最好市场成功率
- 研究：花费中等时间程序员所编程序错误最少

**结论**：开发无错误软件所需时间更少！

## 评审（第24章）

### 评审在质量保证中的地位

**核心思想**：开发者对工作中的故障点一无所知，其他人不存在这个盲区。

**"交谈调试"**：
- 程序员解释问题
- 3分钟后自己发现错误（帮助者未发一言）

**评审效果**：
- 评审在发现错误方面比测试更好
- 设计和代码检查：55%、60%错误发现率
- 单元测试：25%错误发现率
- 功能测试：35%错误发现率

**令人难忘的案例**：
- 引入代码检查前：55%联机维护修改错误
- 引入后：只有2%修改错误
- 评审组：0.82错误/100行 vs 非评审组：4.5错误/100行（减少80%）
- Aetna保险公司：82%错误通过检查发现，开发资源减少25%
- IBM Orbit项目：错误仅为正常1%

### 评审的价值

**主要目的**：
1. 提高软件质量
2. 减少开发时间
3. 传播编程技巧和经验
4. 评估进度
5. 提供反馈

**评审和技术互补**：
- 评审发现测试无法发现的错误类型
- 测试发现评审无法发现的错误类型
- 集成使用最佳

### 检查

**定义**：特殊类型的评审，已被证明有效。

**与普查的区别**：

| 特性 | 检查 | 普查 |
|-----|------|------|
| 正规协调者培训 | 是 | 否 |
| 参与者分工明确 | 是 | 否 |
| 谁"主持" | 协调者 | 通常为作者 |
| 检查表 | 是 | 否 |
| 集中评审常见错误 | 是 | 否 |
| 正规执行 | 是 | 否 |
| 数据分析改进 | 是 | 否 |

**收益**：
- 设计和代码检查联合：去除60%-90%错误
- 比普查少30%错误/1000行
- 提高生产率20%
- 占项目总时间15%

**检查分工**：

1. **协调者**：
   - 控制检查进度
   - 技术胜任能力
   - 不必是被检查代码专家
   - 负责检查一切方面

2. **项目主持者**：
   - 设计者或代码编写者
   - 扮演相对次要角色
   - 解释不清晰部分

3. **检查者**：
   - 对设计或代码有直接兴趣
   - 不是项目主持者
   - 任务是发现缺陷

4. **记录员**：
   - 记录错误和会议情况
   - 可由协调者兼任
   - 主持者或检查者不兼任

5. **管理者**：
   - 有权知道检查结果
   - 不应参加检查会议（改变技术相互作用）
   - 检查结果不应用作性能评估

**最佳规模**：至少3人（协调者、主持者、检查者），通常6人左右

**检查过程**：

1. **计划**：
   - 主持者提交设计或代码
   - 协调者决定参与者
   - 确定时间地点
   - 分发材料

2. **总览**（可选）：
   - 主持者介绍环境
   - 约1小时
   - 可能造成不清晰假象

3. **准备**：
   - 每位检查者花90分钟熟悉材料
   - 使用检查表
   - 应用程序代码：700行/小时
   - 系统程序代码：125行/小时

4. **检查会议**：
   - 主持者解释设计或代码
   - 所有逻辑都要解释
   - 记录错误
   - 不讨论解答，只确定错误
   - 不超过2小时

5. **检查报告**：
   - 列出每个错误类型和严重性
   - 产生错误表
   - 收集时间和错误数据

6. **再工作**：
   - 主持者改正错误
   - 超过5%需再加工→重新检查
   - 低于5%→可要求再检查或亲自证实

**检查本身**：
- 侧重错误发现，不是纠错
- 对主持者积极有意义
- 不批评主持者
- 尊重主持者最终决定权

**检查表**：
- 着重将注意力引向常见错误区域
- 侧重缺陷检查而非纠错
- 充足准备时间
- 不同角色分工
- 会议≤2小时
- 协调者受过训练
- 收集错误类型数据
- 收集准备和检查率
- 确认条款落实
- 管理者明白不参会

### 其它评审方法

**普查**：
- 灵活的评审方法
- 30-70%错误发现率
- 30-60分钟
- 侧重发现错误，不纠错
- 管理人员不参加
- 效果可能差异很大（30%-70%）

**代码阅读**：
- 个人对代码评审，而非会议讨论
- 3.3错误/小时 vs 调试1.8错误/小时
- 比调试多发现20%-60%错误
- 评审者独立阅读，约1000行/天
- 1-2小时讨论会
- 时间节省，会议少

**软件演示**：
- 向用户展示软件
- 管理评审，非技术评审
- 不指望靠它提高技术质量
- 可能间接影响（改进用户界面）

## 单元测试（第25章）

### 单元测试在质量保证中的作用

**现实**：
- 测试是最流行的质量方法
- 但评审比测试更有效（错误发现率更高，代价减半）
- 单一测试方法只能发现<50%错误
- 集成测试可达99%错误发现率

**测试的困难**：
- 目的同其它开发活动矛盾（发现错误vs防止错误）
- 结果只证实错误存在，不能证实多少
- 仅用测试不能提高质量（如称重不能减肥）
- 需要假定能找到错误

**时间分配**：
- 占项目时间8%-35%
- 小项目：35%
- 大项目：8%

### 测试方法

**结构化测试**：
- 测试每条语句至少一次
- 计算最少测试用例数

**计算测试用例**：
1. 从1开始计数
2. 每遇关键词加1：if、while、repeat、for、and、or
3. case语句：每个case加1，无default加1

**数据流测试**：
- 基于数据使用同控制流一样易错
- 现代程序至少一半数据说明和初始化错误

**数据状态**：
- 已定义：已初始化未使用
- 已使用：用于计算
- 已失效：失去定义

**反常序列**：
- 定义-定义：浪费
- 定义-退出：局部变量正常
- 定义-失效：浪费
- 失效-失效：双重释放错误
- 失效-使用：逻辑错误
- 使用-定义：检查以前定义

**等效类划分**：
- 覆盖大部分可能输入
- 减少测试用例数

**错误猜测**：
- 建立在直觉或经验上
- 测试边界条件
- 测试坏数据（太小、太大、错误类型、错误长度、未初始化）
- 测试好数据（最小配置、最大配置、兼容性）

**边界分析**：
- 测试最大值、最小值
- 小于最大、等于最大、大于最大
- 复合边界（多个变量）

### 典型错误

**错误集中**：
- 80%错误出现在20%子程序中
- 50%错误出现在10%子程序中
- 20%子程序占用80%开发代价

**错误排序**：
1. 结构错误：25.18%
2. 数据错误：22.44%
3. 功能实现错误：16.19%
4. 实现错误：9.88%
5. 系统错误：8.98%
6. 功能需求错误：8.12%
7. 测试定义或执行：2.76%
8. 系统、软件结构错误：1.74%
9. 其它：4.71%

**关键洞察**：
- 85%错误可通过修改≤1个子程序发现
- 95%错误由程序员引起（2%系统软件，1%硬件）
- 36%书写错误（某研究）
- 41%赋值语句错误，但发现时间是其它3倍
- 85%错误几小时可改好，15%需几小时到几天

### 测试支持工具

**脚手架**：
- 残桩：低级子程序，可被高级调用
- 驱动：调用测试子程序
- 虚拟文件：测试用，小且内容确切

**结果比较**：
- 自动比较实际输出和预期输出
- 文件比较工具

**测试数据生成程序**：
- 产生随机测试数据
- 深入检查程序

**覆盖监控**：
- 跟踪已运行和未运行代码
- 告诉是否需要增加测试用例

**符号调试程序**：
- 单步调试
- 变量追踪
- 解释代码

**系统测试工具**：
- 存储器填充
- 存储器检查
- 可选择存储器失效
- 存储器访问检查（边界检查）

### 提高测试质量

**计划测试**：
- 从项目开始就计划
- 使测试可重复
- 测试计划和设计、编码同样重要

**回归测试**：
- 修改后重新测试
- 防止质量倒退
- 52%被调查者不熟悉回归测试（危险的信号）
- 自动化是唯一可行方法

**测试记录**：
- 管理性描述
- 问题描述
- 重复方法
- 建议处理方法
- 相关错误
- 严重性
- 错误排序
- 错误位置
- 修改影响
- 发现/改正时间

**度量分析**：
- 每个子程序错误数
- 每个错误平均测试时间
- 每个错误平均测试用例数
- 测试覆盖率
- 各严重错误数

## 调试（第26章）

### 概述

**定义**：发现错误根源并改正它。
- 测试：发现错误
- 调试：诊断和改正错误

**调试差异**：
- 有经验程序员调试时间比从20:1到更悬殊
- 最好程序员：5.0分钟/错误，漏掉0.7个，产生3.0个新错误
- 最差程序员：14.1分钟/错误，漏掉1.7个，产生7.7个新错误

**调试是学习机会**：
- 加深对程序了解
- 了解错误类型
- 从别人角度看代码质量
- 学习解决问题方法
- 学习如何改正

### 调试误区

❌ **不要**：
- 靠猜测发现错误（胡乱插入输出语句）
- 不花时间理解问题
- 用明显方式改正（特殊用例修补）
- 对调试迷信（怪机器、编译器、数据、满月）

✅ **应该**：
- 使用科学方法

### 科学调试方法

**步骤**：
1. 固定错误
2. 确定错误源
3. 改正错误
4. 测试修改
5. 寻找类似错误

**对应科学方法**：
1. 通过重复实验收集数据
2. 建立假设解释尽可能多数据
3. 设计实验证实或否定假设
4. 证实或否定假设
5. 重复以上步骤

### 找错技巧

**固定错误**：
- 使间歇性错误定期发生
- 简化测试用例
- 非相关因素建立假设，改变并测试

**确定错误位置**：
- 使用科学方法
- 检查假设
- 细心改变测试用例观察错误表现

**发现错误诀窍**：
- 使用所有可能数据建立假设
- 求精产生错误的测试用例
- 通过不同方法再生错误
- 产生更多数据生成更多假设
- 使用否定测试结果
- 提出尽可能多假设
- 缩小可疑代码区（二分法）
- 检查最近修改代码
- 扩展可疑代码区
- 逐步集成
- 怀疑以前出错子程序
- 耐心检查
- 为迅速调试设定最大时间（超时改用稳重方法）
- 检查一般错误（检查表）
- 跟别人谈论问题（交谈调试）
- 暂时终止考虑问题

**语法错误**：
- 不相信编译程序行数
- 不相信编译信息
- 不相信二次信息（改正第一个重新编译）
- 分解程序
- 寻找另外的注释和引号

### 修改错误

**原则**：
- 在改正前真正了解其实质
- 理解整个程序，不只是问题
- 确诊错误
- 放松自己（避免匆忙）
- 保存初始源代码
- 修改错误问题，不是症状
- 仅当有确切原因时修改
- 每次作一个修改
- 检查修改
- 重新运行整个程序
- 寻找相似错误

**示例**：
```pascal
// 错误示例
for ClaimNumber := 1 to NumClaims[Client] do
begin
  Sum[Client] := Sum[Client] + ClaimAmount[ClaimNumber]
end;

// ❌ 糟糕的修改
if (Client = 45) then
  Sum[45] := Sum[45] + 3.45;

// ✅ 正确的修改
// 找出初始化错误的真正原因并修复
```

### 调试工具

**源代码比较程序**：
- 比较新旧版本
- 确定修改

**编译警告错误**：
- 警告级设为最高
- 修改代码不产生警告
- 视警告为严重错误
- 为整个项目设立标准

**扩展语法和逻辑检查**：
- lint工具（C）
- 详细检查

**执行剖析程序**：
- 揭示隐含错误
- 检查时间分配

**调试程序**：
- 设置断点
- 单步执行
- 变量追踪
- 向前向后执行

### 调试心理因素

**心理设置**：
- 将所见误认为期望看到的
- 例如：Num看成Number
- "THE THE"例子：只看到一个"the"

**影响调试**：
1. 良好编程习惯重要性（格式、注释、变量名）
2. 对部分程序挑选的影响
3. 变量名心理差距

**变量名心理差距**：
- STOPPT vs ST0PPT：几乎不可见
- SHIFTRE vs SHIFTRT：几乎没有
- CLAIMS1 vs CLAIMS2：小
- GCOUNT vs CCOUNT：小
- PRODUCT vs SUM：大

**建议**：选择有较大差别的变量名

## 系统集成（第27章）

### 集成方法重要性

**类比**：华盛顿大学足球馆坍塌
- 建造中强度不足以支撑自身重量
- 错误的集成顺序
- 软件同样：错误集成顺序 → 无法完成

**递增集成的好处**：
- 易于诊断错误
- 更少的错误
- 少量连接框架
- 短期内形成首次可工作系统
- 短期全面开发计划
- 良好用户关系
- 增强信心
- 增加完成机会
- 更可靠预测
- 提高代码质量
- 减少文件

### 分段集成（Big Bang）

**步骤**：
1. 设计、编程、检查、调试（单元开发）
2. 合并成大系统（系统集成）
3. 检查和调试整个系统（系统再集成）

**问题**：
- "爆炸扩张集成"
- 新问题不可避免显露
- 问题原因可能在系统任何部位
- 所有程序被怀疑
- 问题同时突然出现
- 难以诊断

**适用**：非常小的项目（2-3个分支）

### 递增集成

**通用方法**：
1. 开发小的功能块（最硬、关键或最小）
2. 彻底检查、调试（作为骨架）
3. 设计、编码、检查、调试新程序
4. 集成到脚手架，检查、调试组合
5. 重复直到完成

**优越性**：
- **容易确定错误位置**：错误一定在新程序上
- **系统尽早成功**：50%比99%实在
- **更充分测试**：比分段集成更多被运行
- **并行开发**：部分编码，部分设计

### 递增集成策略

**自顶向下**：
- 最先集成顶层程序
- 使用存根（stub）
- 最后集成底层程序

**优点**：
- 系统逻辑控制尽早测试
- 大概念问题很快暴露
- 可快速有基本接口

**缺点**：
- 最后才脱离硬件接口
- 占据所有顶层到底联系
- 需要大量接口

**自底向上**：
- 最先集成底层程序
- 使用测试驱动程序（driver）
- 最后集成顶层程序

**优点**：
- 早期硬件接口测试
- 递增集成优点

**缺点**：
- 最后才能脱离主要高层接口
- 高层设计问题晚期发现
- 必须先完成所有设计

**三明治集成**：
- 从顶层和底层开始
- 最后集成中层（像三明治面包）

**定向冒险集成**：
- 识别危险层次（最易出错）
- 从最危险部分开始
- 顶层接口、硬件接口常排前

**功能定向集成**：
- 一次集成某一功能的所有程序
- 功能块挂到框架上
- 支持目标定向设计

### 改进的公布法

**通用方法**：
在完整连续层次中首先公布程序，每一层都是可用的程序版本。

**示例**（电子表格）：
- 公布1：基本接口、数学计算、简单数据输入
- 公布2：公式和复杂数据输入
- 公布3：存储文件功能
- 公布4：数据库操作
- 公布5：画图功能
- 公布6：与其他产品接口
- 公布7：调整运行产品
- 公布8：完整系统产品

**重点**：
- 第一次公布是最终产品核心
- 顺序加入更多功能
- 灵活性响应用户要求变化

**优点**：
- **集成照顾自己**：快速频繁集成减少问题
- **缩短产品发货周期**：可工作版本随时可用
- **用户满意**：尽早看到系统，提出改进建议
- **易于获得工程状态**：频率里程碑表
- **减少估计错误**：多次小估计代替一次大估计
- **平衡分配资源**：分析、设计、编码、测试统一分配
- **增强信心**：部分可工作产品鼓舞士气
- **增加完成可能性**：50%可工作>90%不可工作
- **提高代码质量**：自己多次读和修改编码
- **早期发现可修改性**：多次释放测试是否支持修改
- **更少文件**：每个小工程适度文件，总量比大工程少

**与原型开发关系**：
- 改进公布法≠原型开发
- 原型：探测性，可能废弃
- 改进公布：每版本都可接受，是最终产品步骤

**限制**：
- 需要更多计划
- 需要更多技术投资（保持清洁代码）
- 应用目的明确时可能浪费

## 质量保证检查清单

### 项目规模意识

- [ ] 是否了解项目规模对开发的影响？
- [ ] 是否考虑了交流途径的指数增长？
- [ ] 是否根据项目规模调整活动比例？
- [ ] 是否了解规模对错误和生产率的影响？
- [ ] 是否区分了程序、产品、系统、系统产品的复杂度？

### 创建管理

- [ ] 是否使用了好的代码方法（结对编程、代码阅读等）？
- [ ] 是否有配置管理计划？
- [ ] 是否使用了版本控制软件？
- [ ] 是否定期备份并测试恢复？
- [ ] 评估方法是否多样化？
- [ ] 是否收集了度量数据？
- [ ] 是否考虑了程序员能力和时间分配？
- [ ] 是否提供了良好的物理环境？

### 质量目标

- [ ] 是否明确了项目质量目标？
- [ ] 是否让每个人都了解目标？
- [ ] 是否考虑了外部和内部特征？
- [ ] 是否考虑了特征间的矛盾和促进关系？

### 质量方法

- [ ] 是否使用了多种错误检查方法？
- [ ] 是否包括设计检查？
- [ ] 是否包括原型开发？
- [ ] 是否包括代码评审？
- [ ] 是否包括运行测试？
- [ ] 是否尽早发现错误？

### 评审

- [ ] 是否使用了检查方法？
- [ ] 是否有明确的角色分工？
- [ ] 是否使用了检查表？
- [ ] 会议时间是否≤2小时？
- [ ] 是否收集了错误数据？
- [ ] 是否确认了再工作？

### 测试

- [ ] 是否每个需求都有测试用例？
- [ ] 是否覆盖了所有代码路径？
- [ ] 是否考虑了数据流测试？
- [ ] 是否使用了错误猜测？
- [ ] 是否测试了边界条件？
- [ ] 是否测试了错误数据？
- [ ] 是否测试了回归？
- [ ] 是否记录了测试数据？

### 调试

- [ ] 是否使用科学方法而非猜测？
- [ ] 是否理解问题本质才修改？
- [ ] 是否一次只作一个修改？
- [ ] 是否寻找相似错误？
- [ ] 是否使用了调试工具？
- [ ] 是否注意了心理因素影响？

### 系统集成

- [ ] 是否使用了递增集成而非分段集成？
- [ ] 是否选择了合适的集成策略？
- [ ] 是否考虑了改进公布法？
- [ ] 是否尽早提供了可工作版本？
- [ ] 是否频繁集成和测试？

## 常见错误

### ❌ 不要

1. **忽视项目规模影响**
   - 用小项目经验估计大项目
   - 忽视交流复杂性

2. **缺少配置管理**
   - 无版本控制
   - 不定期备份
   - 修改失控

3. **单一质量保证方法**
   - 只依赖测试
   - 不进行评审

4. **调试靠猜测**
   - 胡乱修改代码
   - 不理解问题就修改

5. **分段集成**
   - 一次性集成所有代码
   - 错误难以定位

6. **忽视度量**
   - 不收集数据
   - 无质量基线

### ✅ 应该

1. **规模意识**
   - 根据规模调整方法和计划
   - 简化大项目交流

2. **配置管理**
   - 使用版本控制
   - 定期备份
   - 控制修改流程

3. **多种质量方法**
   - 评审+测试+原型
   - 尽早发现错误

4. **科学调试**
   - 系统方法找错
   - 理解后修改

5. **递增集成**
   - 逐步集成
   - 早期提供可工作版本

6. **度量驱动**
   - 收集数据
   - 持续改进

## 何时参考此内容

查阅此材料当：
- 评估项目规模和影响
- 制定质量保证计划
- 组织评审活动
- 设计测试策略
- 调试复杂问题
- 规划系统集成
- 进行代码评审
- 收集和分析质量度量
- 改进开发流程

## 相关阅读

- **子程序设计**：参见 [02-routines.md](02-routines.md)
- **模块化设计**：参见 [03-design.md](03-design.md)
- **数据相关**：参见 [04-data.md](04-data.md)
- **控制结构**：参见 [05-statements.md](05-statements.md)
- **代码风格**：参见 [06-code-style.md](06-code-style.md)

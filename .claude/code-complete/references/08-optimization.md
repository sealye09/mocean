# 代码优化

**基于《Code Complete 代码大全》第28-30章**

## 概述

代码优化是提高软件性能和可维护性的重要活动。本章涵盖性能优化策略、具体的代码调整技术，以及软件进化和重构的方法。

**核心观点**：优化应该是有针对性的、基于测量的，并且不应损害代码质量。正确性永远优先于性能。

## 代码调整策略（第28章）

### 性能优化的层次

**从高到低的优化层次**：

1. **程序设计**
   - 影响最大：可达百万倍改进
   - 例如：选择不同的算法或数据结构

2. **模块和子程序设计**
   - 例如：选择快速排序而非冒泡排序

3. **操作系统交互**
   - 减少系统调用次数
   - 优化I/O操作

4. **编译器**
   - 使用优化编译器
   - 可提高30%或更多性能

5. **硬件**
   - 对于少量用户，买新硬件可能是最经济的方案

6. **代码调整**
   - 影响最小，通常是最后手段
   - 典型改进：10%-20%

**关键洞察**：每一层都可能获得成倍改进，累计潜力巨大。

### 代码调整的常见误区

❌ **错误观念 1**：减少高级语言代码行数能提高执行速度

**反例**：
```c
// 一行代码 - 看似简洁
for i=1 to 5 do a[i]=i

// 五行代码 - 实际快80%+
a[1]=1
a[2]=2
a[3]=3
a[4]=4
a[5]=5
```

**测试数据**：
- Pascal：6:1 速度比
- Basic：7:1 速度比

❌ **错误观念 2**：某种操作一定比另一种快

**现实**：性能因语言、编译器、硬件而异。必须测量才能确定。

❌ **错误观念 3**：应该处处优化程序

**问题**：
- 不知道真正的瓶颈在哪里
- 过早优化是万恶之源
- 损害可读性和可维护性

❌ **错误观念 4**：快速程序和正确程序同样重要

**现实**：正确性永远第一。不能工作的快速程序毫无价值。

### Pareto原理（80/20定律）

**核心原则**：
- 20%的代码占用80%的执行时间
- Donald Knuth发现：不到4%的程序占用超过50%运行时间

**优化策略**：
1. 测量程序找出热点代码
2. 集中优化那20%的频繁执行代码
3. 忽略不常执行的80%代码

**案例**：
- Jon Bentley：5行求平方根代码占1000行程序80%时间
- 优化这5行速度3倍 → 整体程序提速2倍
- 另一组：优化循环10倍，但系统性能未改善（优化了错误的地方）

### 测量的重要性

**为什么必须测量**：
1. 代码行数与执行时间不成比例
2. 性能表现常违反直觉
3. 经验不可靠（来自不同的环境）
4. 编译器优化可能已做了你的工作

**案例**：矩阵求和优化尝试

```c
// 原始版本
Sum=0;
for(Row=0; Row<RowCount; Row++) {
    for(Column=0; Column<ColumnCount; Column++) {
        Sum=Sum + Matrix[Row][Column];
    }
}

// "优化"版本 - 用指针代替数组索引
Sum =0;
Elementptr = Matrix;
LastElementptr = Matrix[RowCount-1][ColumnCount-1] + 1;
While(Elementptr < LastElementptr) {
    Sum += *Elementptr++;
}
```

**结果**：零改进！编译器已经优化得足够好了。

**教训**：没有测量保证的优化，往往只是让代码更难读。

### 测量指南

**精确测量要求**：
- 使用性能分析工具（profiler）
- 在多任务系统中，用CPU周期数而非时间
- 确保只测量目标代码的执行时间
- 避免其他进程干扰

**编译器优化效果**：

插入排序测试：

| 语言 | 无优化 | 有优化 | 节省 | 速度比 |
|-----|-------|-------|-----|-------|
| Ada | 2.80 | 1.60 | 43% | 2:1 |
| C编译器1 | 2.25 | 1.65 | 27% | 4:3 |
| C编译器2 | 2.58 | 2.58 | 0% | 1:1 |
| C编译器3 | 2.31 | 0.99 | 57% | 2:1 |

**结论**：
- 好的优化编译器比手工调整更有效
- 简单代码比复杂代码优化效果好
- 写清晰的代码，让编译器去优化

### 何时调整代码

**正确顺序**：
1. 用高质量设计开发软件
2. 使程序正确、模块化、易修改
3. 测量性能，找出瓶颈
4. 判断是否需要代码调整
5. 调整并测量每次改进
6. 如果无效，放弃重来

**迭代优化**：
- 多次小优化的累积效果显著
- 案例：从21分40秒优化到22秒（98%改进）
  - 30次迭代
  - 单次改进通常3%-5%
  - 累积效果惊人

### 低效率的常见来源

**1. 输入输出操作**
- 内存访问比外部文件快约100倍
- 随机访问差别更大（800:1）
- **建议**：尽量使用内存数据结构

**2. 格式化输出**
- 格式化语句占用大量空间
- 例如：C的printf vs 简单输出
- **建议**：非必要时避免格式化

**3. 浮点运算**
- 在软件中模拟浮点非常慢
- 一次浮点操作可能引入整个浮点库（15K+）
- **建议**：能用整型就用整型

**4. 分页错误**
- 跨页访问引发缺页中断
- **案例**：2K页初始化从5秒降到<0.001秒
  - 改变循环次序
  - 从按列访问改为按行访问

**5. 系统调用**
- 系统调用开销大
- **建议**：
  - 自己写服务程序
  - 减少调用次数
  - 与供应商合作改进

### 操作相对耗时参考

**整数操作**（基准：赋值=1）：
- 加减法：2-3
- 乘法：2-3
- 除法：4-5
- 数组访问：2-4
- 指针访问：2-2.6

**浮点操作**（硬件不支持时）：
- 赋值：5-85
- 加减法：150-300
- 乘除法：150-300
- 平方根：300-500
- 三角函数：700-1000
- 对数/指数：1200-2000

**子程序调用**：6-8

**关键观察**：
- 浮点操作比整型慢10-1000倍
- 函数调用（三角/对数）极其昂贵
- 乘除法比加减法慢
- 指针访问不一定比数组快

## 代码调整技术（第29章）

### 代码调整方法

**步骤**：
1. 用高度模块化设计开发
2. 如果性能差，测量系统找出热点
3. 判断弱点是否源于设计/算法/数据结构
4. 调整已识别的薄弱环节
5. 测量每个改进的效果
6. 重复步骤2-5

### 循环优化

**1. 将判断移出循环**

❌ **低效**：
```c
for(i=0; i<1000; i++) {
    if(UserType == ADMIN_USER) {
        // 管理员操作
    } else {
        // 普通用户操作
    }
}
```

✅ **高效**：
```c
if(UserType == ADMIN_USER) {
    for(i=0; i<1000; i++) {
        // 管理员操作
    }
} else {
    for(i=0; i<1000; i++) {
        // 普通用户操作
    }
}
```

**2. 合并循环**

❌ **低效**：
```c
for(i=0; i<100; i++) {
    SumA += ArrayA[i];
}
for(i=0; i<100; i++) {
    SumB += ArrayB[i];
}
```

✅ **高效**：
```c
for(i=0; i<100; i++) {
    SumA += ArrayA[i];
    SumB += ArrayB[i];
}
```

**3. 展开循环（慎重）**

```c
// 展开4次
for(i=0; i<1000; i+=4) {
    Sum += Array[i];
    Sum += Array[i+1];
    Sum += Array[i+2];
    Sum += Array[i+3];
}
```

**注意**：现代编译器通常会自动做这个优化。

**4. 最小化循环内工作**

❌ **低效**：
```c
for(i=0; i<1000; i++) {
    CommissionRate = CalculateRate(); // 每次都算
    Total += Sales[i] * CommissionRate;
}
```

✅ **高效**：
```c
CommissionRate = CalculateRate(); // 只算一次
for(i=0; i<1000; i++) {
    Total += Sales[i] * CommissionRate;
}
```

**5. 使用哨兵值**

```c
// 传统方式
i = 0;
while(i < Count && Array[i] != Target) {
    i++;
}
if(i < Count) {
    // 找到了
}

// 哨兵方式
Array[Count] = Target; // 哨兵
i = 0;
while(Array[i] != Target) {
    i++;
}
if(i < Count) {
    // 找到了
}
```

**优势**：每次循环少一次比较。

### 逻辑优化

**1. 简化表达式**

```c
// 简化前
if((Character >= 'a' && Character <= 'z') ||
   (Character >= 'A' && Character <= 'Z')) {
    // 是字母
}

// 简化后（使用库函数）
if(isalpha(Character)) {
    // 是字母
}
```

**2. 用查表代替复杂计算**

```c
// 计算方式
for(i=0; i<360; i++) {
    Result[i] = sin(i * PI / 180.0);
}

// 查表方式
for(i=0; i<360; i++) {
    Result[i] = SinTable[i];
}
```

**3. 利用短路求值**

```c
// 先判断快的情况
if(QuickCheck && ExpensiveCheck) {
    // ...
}

// 先判断大概率失败的情况
if(RareCondition && CommonCondition) {
    // ...
}
```

### 数据结构优化

**1. 用整数代替浮点**

```c
// 浮点方式
float Price = 19.99;

// 整数方式（以分为单位）
int Price = 1999; // 19.99元
```

**2. 使用数组代替链表**

- 数组访问：O(1)
- 链表访问：O(n)
- 如果不需要频繁插入/删除，数组更优

**3. 缓存常用值**

```c
// 每次都计算
for(i=0; i<1000; i++) {
    result = x * x + y * y + sqrt(z);
}

// 缓存中间值
xx = x * x;
yy = y * y;
sqrt_z = sqrt(z);
temp = xx + yy + sqrt_z;
for(i=0; i<1000; i++) {
    result = temp;
}
```

### 表达式优化

**1. 强度削弱（用快操作代替慢操作）**

```c
// 慢操作
x = x * 2;
x = x * 4;
x = pow(x, 2);

// 快操作
x = x << 1;  // 左移代替乘2
x = x << 2;  // 左移代替乘4
x = x * x;   // 乘法代替pow
```

**2. 公共子表达式消除**

```c
// 低效
Total = Price * Quantity + Tax * Quantity;
Final = Price * Quantity - Discount * Quantity;

// 高效
PriceQuantity = Price * Quantity;
Total = PriceQuantity + Tax * Quantity;
Final = PriceQuantity - Discount * Quantity;
```

**3. 常量折叠**

```c
// 编译器会自动优化
x = 365 * 24 * 60;  // 变成 x = 525600
```

### 子程序优化

**1. 内联小函数**

```c
// 函数调用
inline int Square(int x) {
    return x * x;
}

// 编译器可能会内联展开
result = Square(value);
// 变成 result = value * value;
```

**2. 减少参数数量**

- 参数传递有开销
- 使用全局变量（谨慎）或结构体

**3. 避免递归**

```c
// 递归阶乘
int Factorial(int n) {
    if(n <= 1) return 1;
    return n * Factorial(n-1);
}

// 迭代阶乘（更快）
int Factorial(int n) {
    int result = 1;
    for(int i=2; i<=n; i++) {
        result *= i;
    }
    return result;
}
```

### 使用汇编代码

**何时考虑**：
- 所有其他方法都已尝试
- 热点代码已确认
- 小段关键代码
- 性能提升明显

**注意事项**：
- 牺牲可读性
- 牺牲可移植性
- 维护困难
- 现代编译器通常已经足够好

**建议**：
- 99%的情况不需要汇编
- 除非你有特殊需求且测量证明有效

## 软件优化（第30章）

### 软件进化的现实

**设想 vs 现实**：

设想：精心策划的软件，主要修改在维护阶段

现实：
- 从初始设计到结束，约25%需求会改变
- 现代"以代码为中心"方法使大修改成为可能
- 设计、编程、调试占25%-70%工作量

**软件进化的标志**：
- 修改后质量提高还是下降？
- 调整是结构性还是维护性的？

**核心原则**：软件进化的基本规则——内部质量应随时间提高。

### 软件优化指南

**核心目标**：提高程序的内在质量

**具体原则**：

1. **多设计子程序**
   - 模块化使修改更容易
   - 如果某段代码能独立成子程序并更清晰，就这样做

2. **减少全局变量**
   - 检查是否可以避免使用全局变量
   - 将它们局限在分段程序中

3. **改进编程风格**
   - 整理变量命名
   - 改善布局
   - 添加必要注释

4. **使用版本控制**
   - 跟踪多版本源程序
   - 比较版本找出错误
   - 安全地回退

5. **重审修改后的程序**
   - 修改时需要50%以上的改动是正常的
   - 修改5行以上时，越改越糟的可能性增加
   - 像对付复杂改动那样对付简单改动

6. **重测试（回归测试）**
   - 用测试验证修改效果
   - 确保未引入新错误
   - 10个最昂贵的错误都涉及修改现存程序

**软件优化的哲学**：
- 优化既是危险又是完善的机会
- 力图使以后修改变得更容易
- 记住源程序及所做的修改

### 创建新子程序

**核心思想**：将大程序分成2-3个新程序

**优势**：
- 小子程序比加大注释好
- 子程序不像注释那样易过时
- 提高模块化程度
- 简化程序维护

**何时创建新子程序**：

**1. 降低复杂度**

```pascal
// 复杂的命令解释程序
procedure DisplayCommand(CommandSentence: string);
begin
    // 检查命令有效性
    // 展开命令缩写
    // 提取参数
    // 显示命令和参数
end;

// 拆分成子程序
function CommandFromWord(CommandCode: char): string;
begin
    case CommandCode of
    'L': CommandFromWord := 'Left';
    'R': CommandFromWord := 'Right';
    // ...
    end;
end;

procedure DisplayCommand(CommandSentence: string);
begin
    CommandWord := CommandFromWord(CommandSentence[2]);
    // 提取参数
    // 显示命令和参数
end;
```

**2. 减少嵌套层次**

```c
// 深度嵌套
void ReadEmployeeData() {
    for(FieldIdx=0; FieldIdx<Employee.NumFields; FieldIdx++) {
        for(CharIdx=0; CharIdx<Length; CharIdx++) {
            // 验证字符
        }
    }
}

// 提取子程序
boolean ValidateEmployeeRec(EMPLOYEE Employee) {
    for(FieldIdx=0; FieldIdx<Employee.NumFields; FieldIdx++) {
        for(CharIdx=0; CharIdx<Length; CharIdx++) {
            // 验证字符
        }
    }
}

void ReadEmployeeData() {
    ValidRecord = ValidateEmployeeRec(NewEmployee);
}
```

**优势**：
- 程序更短
- 嵌套更浅
- 可读性增强
- 模块化提高

### 代码共享策略

**问题**：新功能需要类似代码，如何共享？

**三种策略**：

**1. 低层共享（推荐）**
- 提取共享代码为新子程序
- 从多处调用
- 提高模块化

**2. 复制代码（不推荐）**
- 复制到各处
- 占空间
- 维护困难

**3. 高层共享**
- 创建高层子程序处理普遍情况
- 用低层子程序处理差异
- 减少框架代码

**示例**：温度获取

```pascal
// 原始代码
Temperature := StackTemperature[Stack.Top];
StackTemperature[Stack.Top] := INITAL_TEMPERATURE;
if(Stack.Top>0) then
    Stack.Top := Stack.Top-1;

// 提取子程序
procedure MostRecentTemperature(var stack: STACK_TYPE;
                               var Temperature: integer);
begin
    Temperature := StackTemperature[Stack.Top];
    StackTemperature[Stack.Top] := INITAL_TEMPERATURE;
    if(Stack.Top>0) then
        Stack.Top := Stack.Top-1;
end;

// 调用
MostRecentTemperature(Stack, Temperature);
```

**优势**：
- 代码共享
- 提高抽象程度
- 信息隐藏
- 更清晰的接口

### 高层代码共享示例

**场景**：导弹信息目录系统

**初始**：只记录位置信息

**扩展**：需要处理多种信息类型

**方案1**：低层共享
- 创建通用子程序：ReadMessage(), CheckMessage(), CheckMessageFields(), SaveMessage()
- 为每种消息类型调用这些通用程序

**方案2**：高层共享
- 创建高层框架处理通用流程
- 创建低层程序处理各类型差异
- 减少框架代码，提高抽象

**选择原则**：
- 多数情况从低层共享受益
- 不要忽视高层共享的可能性
- 某些情况下高层共享效果更好

## 代码优化检查清单

### 优化策略

- [ ] 是否测量了性能找出瓶颈？
- [ ] 是否确认瓶颈不是设计/算法问题？
- [ ] 是否尝试了编译器优化？
- [ ] 是否考虑了硬件升级？
- [ ] 优化是否基于实际测量而非猜测？
- [ ] 是否正确性优先于性能？

### 循环优化

- [ ] 是否将不变判断移出循环？
- [ ] 是否可以合并多个循环？
- [ ] 是否最小化循环内的工作量？
- [ ] 是否使用了哨兵值？
- [ ] 循环展开是否有效？（测量验证）

### 逻辑优化

- [ ] 是否简化了复杂表达式？
- [ ] 是否可以用查表代替计算？
- [ ] 是否利用了短路求值？
- [ ] 是否避免了重复计算？

### 数据优化

- [ ] 能否用整型代替浮点？
- [ ] 数据结构是否合适？（数组 vs 链表）
- [ ] 是否缓存了常用值？
- [ ] 是否减少了内存分配？

### 表达式优化

- [ ] 是否用快操作代替慢操作？（强度削弱）
- [ ] 是否消除了公共子表达式？
- [ ] 是否利用了常量折叠？

### 子程序优化

- [ ] 小函数是否可以内联？
- [ ] 是否减少了参数数量？
- [ ] 是否避免了不必要的递归？
- [ ] 是否考虑了汇编代码？（谨慎）

### 软件进化

- [ ] 修改是否提高了内在质量？
- [ ] 是否创建了新的子程序提高模块化？
- [ ] 是否减少了全局变量？
- [ ] 是否改进了编程风格？
- [ ] 是否使用了版本控制？
- [ ] 是否重审了修改后的代码？
- [ ] 是否进行了回归测试？
- [ ] 修改是否使后续修改更容易？

### 代码共享

- [ ] 是否提取了共享代码？
- [ ] 是否选择了合适的共享层次（低层/高层）？
- [ ] 是否提高了抽象程度？
- [ ] 是否实现了信息隐藏？

## 常见错误

### ❌ 不要

1. **过早优化**
   - 在完成前就优化
   - 不知道瓶颈就优化
   - 过度关注局部而忽视整体

2. **基于假设优化**
   - 不测量就假设哪里慢
   - 相信"某种操作一定更快"
   - 忽视编译器优化

3. **为了优化牺牲质量**
   - 写难读的代码
   - 破坏模块化
   - 引入错误

4. **忽视Pareto原理**
   - 优化不常执行的代码
   - 平均用力而非集中热点

5. **复制代码共享**
   - 为了共享而复制粘贴
   - 导致维护困难

### ✅ 应该

1. **测量驱动优化**
   - 先测量找出热点
   - 基于数据决策
   - 验证每次改进

2. **保持正确性优先**
   - 确保代码正确
   - 不牺牲可读性
   - 可维护性很重要

3. **集中优化热点**
   - 应用80/20定律
   - 优化那20%的代码
   - 忽略不常执行部分

4. **利用编译器优化**
   - 写清晰的代码
   - 让编译器去优化
   - 比手工调整更有效

5. **重构提高质量**
   - 提取子程序
   - 减少复杂度
   - 提高模块化
   - 改进代码结构

## 何时参考此内容

查阅此材料当：
- 需要提高程序性能
- 计划进行代码优化
- 判断是否需要优化
- 选择优化策略
- 应用具体的优化技术
- 重构代码以提高质量
- 进行软件进化
- 修改遗留代码

## 相关阅读

- **高质量程序**：参见 [05-statements.md](05-statements.md)
- **高水平设计**：参见 [03-design.md](03-design.md)
- **模块化设计**：参见 [03-design.md](03-design.md)
- **数据相关**：参见 [04-data.md](04-data.md)
- **代码风格**：参见 [06-code-style.md](06-code-style.md)
- **质量保证**：参见 [07-quality.md](07-quality.md)

---
name: refactoring
description: |
  代码重构助手，基于《重构：改善既有代码的设计(第2版)》。包含30种代码坏味道识别方法和60种重构手法。
  使用场景：
  (1) 识别代码中的坏味道并获取重构建议
  (2) 查找特定重构手法的详细步骤和示例
  (3) 系统化地改善代码结构和可维护性
  (4) 学习重构的最佳实践
---

# 代码重构助手

本 skill 基于 Martin Fowler 的《重构：改善既有代码的设计(第2版)》，提供代码坏味道识别和系统化的重构指导。

## 快速开始

### 识别代码坏味道

当发现代码问题时，可对照以下**30种**坏味道进行识别：

| 坏味道 | 典型特征 | 推荐重构 |
|--------|----------|----------|
| 神秘的命名 | 名字不能清晰表达用途 | 变量改名(137)、函数改名(124)、字段改名(244) |
| 重复代码 | 相同代码结构出现在多处 | 提炼函数(106)、提炼类(182)、函数上移(350)、字段上移(353) |
| 过长函数 | 函数体超过一屏或包含多层抽象 | 提炼函数(106)、拆分阶段(155)、以命令取代函数(337) |
| 过长参数列表 | 参数超过3-4个 | 引入参数对象(140)、保持对象完整(319)、以查询取代参数(324) |
| 全局数据 | 任何地方都可访问和修改 | 封装变量(132)、封装记录(162) |
| 可变数据 | 数据在多处被修改 | 封装变量(132)、以查询取代派生变量(248)、移除设值函数(331)、拆分变量(240) |
| 发散式变化 | 一个类因多种原因修改 | 提炼类(182)、提炼超类(375) |
| 霰弹式修改 | 每次修改需改动多个类 | 搬移函数(198)、以函数调用取代内联代码(217) |
| 依恋情结 | 函数更多使用其他类数据 | 搬移函数(198)、搬移字段(201) |
| 数据泥团 | 总是同时出现的一组数据 | 引入参数对象(140)、提炼类(182) |
| 基本类型偏执 | 过度使用基本类型 | 以对象取代基本类型(174)、封装记录(162) |
| 重复的switch | 相同switch逻辑多处出现 | 以多态取代条件表达式(272)、以子类取代类型码(362) |
| 循环 | 使用传统循环而非管道 | 以管道取代循环(231)、拆分循环(227) |
| 冗赘的元素 | 不再使用的代码 | 移除死代码(237)、内联函数(115)、内联类(186)、折叠继承体系(380) |
| 过度复杂的继承 | 为未存在需求设计的抽象 | 折叠继承体系(380)、移除子类(369)、以委托取代超类(399) |
| 临时字段 | 字段只在特定情况使用 | 提炼类(182)、引入特例(289) |
| 消息链 | a.b.c.d 调用链 | 隐藏委托关系(189) |
| 中间人 | 类大部分函数委托给其他类 | 移除中间人(192)、内联类(186) |
| 过大的类 | 类承担过多责任 | 提炼类(182)、拆分阶段(155) |
| 异曲同工的类 | 不同类做同样事但接口不同 | 改变函数声明(124)、以子类取代类型码(362) |
| 数据类 | 只有数据没有行为 | 封装记录(162)、封装集合(170)、移除设值函数(331) |
| 被拒绝的遗赠 | 子类不需要超类部分功能 | 以委托取代子类(381)、函数下移(359)、字段下移(361) |
| 注释 | 用注释解释"做什么" | 提炼函数(106) |
| 被拒绝的馈赠 | 子类从父类继承但未使用 | 以委托取代子类(381) |
| 不恰当的亲密 | 类之间过度了解彼此内部 | 搬移函数(198)、搬移字段(201)、隐藏委托关系(189) |
| 散弹式修改 | 一个改动影响多个文件 | 搬移函数(198)、组合函数为类(144)、组合函数为变换(149) |
| 令人费解的临时变量 | 变量用途不清晰或多次赋值 | 拆分变量(240)、变量改名(137)、提炼变量(119)、内联变量(123)、以查询取代临时变量(178) |
| 内幕交易 | 类之间通过其他类间接访问 | 隐藏委托关系(189)、以委托取代超类(399)、以委托取代子类(381) |
| 过多的注释 | 用注释解释代码而非改进代码 | 提炼函数(106)、改变函数声明(124)、引入断言(302) |
| 组合爆炸 | 函数通过标记参数选择行为 | 移除标记参数(314)、以多态取代条件表达式(272)、函数参数化(310) |
| 不必要的上下文 | 函数接收完整对象但只用部分数据 | 以查询取代参数(324)、保持对象完整(319) |

### 重构手法分组

根据代码问题类型，选择对应章节的详细参考：

1. **基础重构** → [ch6-first-group.md](references/ch6-first-group.md)
2. **封装相关** → [ch7-encapsulation.md](references/ch7-encapsulation.md)
3. **搬移特性** → [ch8-moving-features.md](references/ch8-moving-features.md)
4. **数据组织** → [ch9-reorganizing-data.md](references/ch9-reorganizing-data.md)
5. **条件逻辑** → [ch10-simplifying-conditionals.md](references/ch10-simplifying-conditionals.md)
6. **API重构** → [ch11-refactoring-apis.md](references/ch11-refactoring-apis.md)
7. **继承关系** → [ch12-handling-inheritance.md](references/ch12-handling-inheritance.md)

## 重构原则

### 两顶帽子

使用重构时，要明确自己当前戴的是哪顶帽子：

- **添加功能**：添加新能力，不修改已有代码
- **重构**：调整代码结构，不添加新功能

不要同时戴上这两顶帽子。

### 重构的定义

> 重构是对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性、降低其修改成本。

### 何时重构

- **事不过三**：同样的代码出现第三次时，进行重构
- **添加功能时**：如果代码结构妨碍添加功能，先重构
- **修复bug时**：如果代码难以理解，先重构
- **代码审查时**：发现需要改进的地方

### 何时不重构

- 需要完全重写时
- 项目临近截止时
- 代码不会被使用时

## 常用重构速查

| 编号 | 名称 | 用途 |
|------|------|------|
| **基础重构** |||
| 106 | 提炼函数 | 将一段代码提取为独立函数 |
| 115 | 内联函数 | 将函数调用替换为函数体 |
| 119 | 提炼变量 | 将表达式提取为变量 |
| 123 | 内联变量 | 将变量替换为表达式 |
| 124 | 改变函数声明 | 修改函数名或参数列表 |
| 132 | 封装变量 | 通过函数访问变量 |
| 137 | 变量改名 | 给变量更好的名字 |
| **封装相关** |||
| 140 | 引入参数对象 | 将多个参数组合成对象 |
| 144 | 组合函数为类 | 将相关函数组织成类 |
| 149 | 组合函数为变换 | 用变换函数组织计算逻辑 |
| 155 | 拆分阶段 | 将代码分为独立阶段 |
| 162 | 封装记录 | 给记录添加封装行为 |
| 170 | 封装集合 | 控制集合的访问方式 |
| 174 | 以对象取代基本类型 | 将基本类型转为对象 |
| 178 | 以查询取代临时变量 | 将临时变量转为查询函数 |
| 182 | 提炼类 | 将类的部分职责提取到新类 |
| 186 | 内联类 | 将一个类合并到另一个类 |
| 189 | 隐藏委托关系 | 隐藏受托对象 |
| 192 | 移除中间人 | 让客户端直接访问受托对象 |
| 195 | 替换算法 | 用更清晰的算法替换旧算法 |
| **搬移特性** |||
| 198 | 搬移函数 | 将函数移到更合适的类 |
| 201 | 搬移字段 | 将字段移到更合适的类 |
| 207 | 搬移语句到函数 | 将调用者代码移到函数内 |
| 213 | 搬移语句到调用者 | 将函数内代码移到调用者 |
| 217 | 以函数调用取代内联代码 | 用语言内置函数替换重复代码 |
| 223 | 滑动语句 | 让相关代码聚集在一起 |
| 227 | 拆分循环 | 将一个循环拆分为多个 |
| 231 | 以管道取代循环 | 用管道操作替换循环 |
| 237 | 移除死代码 | 删除不再使用的代码 |
| **数据组织** |||
| 240 | 拆分变量 | 将一个变量分解为多个 |
| 244 | 字段改名 | 给字段更好的名字 |
| 248 | 以查询取代派生变量 | 用计算代替存储 |
| 252 | 将引用对象改为值对象 | 让对象不可变 |
| 256 | 将值对象改为引用对象 | 引用共享对象 |
| **条件逻辑** |||
| 260 | 分解条件表达式 | 简化复杂条件逻辑 |
| 263 | 合并条件表达式 | 合并相同结果的条件 |
| 266 | 以卫语句取代嵌套条件 | 用卫语句简化嵌套 |
| 272 | 以多态取代条件表达式 | 用多态替换条件逻辑 |
| 289 | 引入特例 | 用特例类处理特殊情况 |
| 302 | 引入断言 | 明确表述程序状态假设 |
| **API重构** |||
| 306 | 将查询函数和修改函数分离 | 分离命令和查询 |
| 310 | 函数参数化 | 用参数统一相似函数 |
| 314 | 移除标记参数 | 用独立函数替换标记参数 |
| 319 | 保持对象完整 | 传递整个对象而非部分数据 |
| 324 | 以查询取代参数 | 用内部查询替换参数 |
| 327 | 以参数取代查询 | 用参数替换内部查询 |
| 331 | 移除设值函数 | 使字段不可变 |
| 334 | 以工厂函数取代构造函数 | 用工厂函数创建对象 |
| 337 | 以命令取代函数 | 将函数转为命令对象 |
| 344 | 以函数取代命令 | 将命令对象转为函数 |
| **继承关系** |||
| 350 | 函数上移 | 将子类函数移到超类 |
| 353 | 字段上移 | 将子类字段移到超类 |
| 355 | 构造函数本体上移 | 将子类构造函数逻辑移到超类 |
| 359 | 函数下移 | 将超类函数移到子类 |
| 361 | 字段下移 | 将超类字段移到子类 |
| 362 | 以子类取代类型码 | 用继承替换类型码 |
| 369 | 移除子类 | 用字段替换子类 |
| 375 | 提炼超类 | 将共同部分提取为超类 |
| 380 | 折叠继承体系 | 合并不再需要的继承层次 |
| 381 | 以委托取代子类 | 用委托替换继承 |
| 399 | 以委托取代超类 | 用委托替换超类 |

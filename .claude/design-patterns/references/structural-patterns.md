# 结构型模式

结构型模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。

---

## 模式列表

| 模式 | 英文 | 主要用途 | 详细文档 |
|------|------|----------|----------|
| 适配器 | Adapter | 让接口不兼容的对象可以协同工作 | [查看 →](structural/adapter.md) |
| 桥接 | Bridge | 将抽象部分与实现部分分离 | [查看 →](structural/bridge.md) |
| 组合 | Composite | 将对象组合成树形结构以表示部分-整体层次 | [查看 →](structural/composite.md) |
| 装饰 | Decorator | 动态地为对象添加行为 | [查看 →](structural/decorator.md) |
| 外观 | Facade | 为子系统中的一组接口提供统一接口 | [查看 →](structural/facade.md) |
| 享元 | Flyweight | 共享对象以减少内存占用 | [查看 →](structural/flyweight.md) |
| 代理 | Proxy | 为其他对象提供代理以控制对这个对象的访问 | [查看 →](structural/proxy.md) |

**快速索引**：[结构型模式总览](structural-patterns.md) | [所有模式文档](README.md)

---

## 结构型模式对比

### 按使用场景分类

| 场景 | 推荐模式 | 理由 |
|------|---------|------|
| 接口不兼容 | 适配器 | 转换接口，使不兼容的对象协同工作 |
| 多维度变化 | 桥接 | 分离抽象与实现，独立变化 |
| 树形结构 | 组合 | 统一处理单个对象和组合对象 |
| 动态添加行为 | 装饰 | 运行时添加职责，不使用继承 |
| 简化复杂系统 | 外观 | 提供简单接口，隐藏复杂度 |
| 节省内存 | 享元 | 共享对象，减少内存占用 |
| 控制访问 | 代理 | 延迟初始化、访问控制、缓存 |

### 模式选择决策树

```
需要处理对象结构
├─ 接口不兼容？
│  └─ 是 → 适配器
│  └─ 否 → 继续
├─ 多个独立变化维度？
│  └─ 是 → 桥接
│  └─ 否 → 继续
├─ 树形结构（部分-整体）？
│  └─ 是 → 组合
│  └─ 否 → 继续
├─ 需要动态添加行为？
│  └─ 是 → 装饰
│  └─ 否 → 继续
├─ 简化复杂系统接口？
│  └─ 是 → 外观
│  └─ 否 → 继续
├─ 对象数量大，需要节省内存？
│  └─ 是 → 享元
│  └─ 否 → 继续
└─ 控制对象访问 → 代理
```

---

## 代码实现

所有结构型模式都有完整的 TypeScript 实现，位于 `src/` 目录：

### 运行示例

```bash
# 适配器模式
ts-node src/Adapter/Conceptual/index.ts

# 桥接模式
ts-node src/Bridge/Conceptual/index.ts

# 组合模式
ts-node src/Composite/Conceptual/index.ts

# 装饰器模式
ts-node src/Decorator/Conceptual/index.ts

# 外观模式
ts-node src/Facade/Conceptual/index.ts

# 享元模式
ts-node src/Flyweight/Conceptual/index.ts

# 代理模式
ts-node src/Proxy/Conceptual/index.ts
```

---

## 相关资源

- [全部结构型模式详细文档](structural/)
- [设计模式总览](README.md)

---

## 适配器 (Adapter)

**定义**：让接口不兼容的对象能够相互合作。

**核心问题**：需要使用一个类，但其接口与你的代码不兼容（如XML数据与只接受JSON的库）。

**解决方案**：
- 创建适配器类，实现客户端期望的接口
- 适配器封装不兼容的对象，转换接口调用
- 客户端只与适配器交互，无需了解被适配对象

**适用场景**：
- 需要使用第三方库，但其接口与现有代码不兼容
- 需要创建多个现有类的复用组件

**结构要点**：
- `Client`：使用目标接口的业务逻辑
- `Client Interface`：客户端期望的接口
- `Service`：不兼容的现有类
- `Adapter`：实现客户端接口，封装服务对象

**实现方式**：对象适配器（组合）或类适配器（多重继承）

---

## 桥接 (Bridge)

**定义**：将大类拆分为抽象和实现两个独立的层次结构，从而可以独立开发。

**核心问题**：当一个类存在多个独立变化维度时，继承会导致类数量爆炸（如形状×颜色）。

**解决方案**：
- 将一个维度抽取为独立的类层次
- 通过组合而非继承来连接两个层次
- 抽象部分引用实现部分，将工作委派给它

**适用场景**：
- 类存在多个独立变化维度
- 需要在运行时切换实现
- 避免类数量爆炸式增长

**结构要点**：
- `Abstraction`：高层控制层，定义抽象接口
- `Implementation`：低层平台接口
- `ConcreteAbstraction`：实现抽象接口，引用实现对象
- `ConcreteImplementation`：具体平台实现

**关键**：分离抽象与实现，使它们可以独立变化。

---

## 组合 (Composite)

**定义**：将对象组合成树状结构，并能像使用独立对象一样使用它们。

**核心问题**：需要处理树形结构（如文件系统、订单中的盒子和产品），希望统一处理单个对象和组合对象。

**解决方案**：
- 声明组件接口，描述树中所有项目共有的操作
- 叶节点实现基本操作
- 容器节点存储子节点，将操作委派给子节点
- 客户端统一对待所有组件

**适用场景**：
- 核心模型能用树状结构表示
- 需要统一处理单个对象和对象组合
- 需要构建树形结构

**结构要点**：
- `Component`：组件接口，声明通用操作
- `Leaf`：叶节点，无子节点
- `Composite`：容器节点，存储子节点列表
- `Client`：通过组件接口与所有对象交互

---

## 装饰 (Decorator)

**定义**：通过将对象放入特殊封装对象中，为原对象绑定新的行为。

**核心问题**：继承无法在运行时动态添加行为，且子类组合数量会爆炸式增长。

**解决方案**：
- 使用组合而非继承
- 装饰器与被装饰对象实现相同接口
- 装饰器封装对象，可以在调用前后添加行为
- 可以嵌套多个装饰器

**适用场景**：
- 需要在运行时为对象添加职责
- 不便使用继承扩展类功能
- 需要动态组合多种行为

**结构要点**：
- `Component`：组件接口
- `ConcreteComponent`：具体组件
- `Decorator`：装饰器基类，持有组件引用
- `ConcreteDecorator`：具体装饰器，添加额外行为

**与代理区别**：装饰添加行为，代理控制访问。

---

## 外观 (Facade)

**定义**：为复杂子系统提供简单接口。

**核心问题**：需要与复杂的库或框架交互，但只需使用其一小部分功能。

**解决方案**：
- 创建外观类，提供简化接口
- 外观处理子系统的初始化和依赖关系
- 客户端只与外观交互

**适用场景**：
- 需要使用复杂系统的有限功能
- 希望隔离复杂系统以简化代码
- 需要将子系统与客户端解耦

**结构要点**：
- `Facade`：外观类，提供简化接口
- `Complex Subsystem`：复杂子系统对象集合
- `Client`：使用外观而非直接访问子系统

**与适配器区别**：外观提供新接口简化系统，适配器转换现有接口。

---

## 享元 (Flyweight)

**定义**：通过共享相同状态，在有限内存中载入更多对象。

**核心问题**：程序包含大量相似对象，导致内存消耗过高。

**解决方案**：
- 将对象状态分为内在状态（可共享）和外在状态（不可共享）
- 只在对象中保存内在状态
- 外在状态由客户端存储并在调用时传递

**适用场景**：
- 程序包含大量相似对象
- 对象的大部分状态可以外部化
- 可以牺牲CPU换取内存

**结构要点**：
- `Flyweight`：享元接口，声明可在外在状态中操作的方法
- `ConcreteFlyweight`：具体享元，存储内在状态
- `Flyweight Factory`：享元工厂，管理享元池
- `Client`：计算或存储外在状态

**关键概念**：内在状态（可共享）vs 外在状态（不可共享）

---

## 代理 (Proxy)

**定义**：提供对象的替代品，控制对原对象的访问，并在请求前后进行处理。

**核心问题**：需要控制对某个对象的访问，或延迟初始化大型对象。

**解决方案**：
- 创建代理类，实现与服务对象相同的接口
- 代理控制对服务对象的访问
- 代理可以在请求前后执行额外操作

**适用场景**：
- 延迟初始化（虚拟代理）
- 访问控制（保护代理）
- 缓存查询结果（缓存代理）
- 远程访问（远程代理）

**结构要点**：
- `Service Interface`：服务接口
- `Service`：服务类，提供实际业务逻辑
- `Proxy`：代理类，控制服务访问
- `Client`：通过接口与代理/服务交互

**与装饰区别**：代理管理对象生命周期，装饰由客户端控制。

---

## 结构型模式关系

- 适配器提供新接口，外观简化现有接口
- 桥接、状态、策略结构相似，但解决的问题不同
- 组合和装饰都依赖递归组合
- 装饰和代理结构相似，但意图不同
- 享元与组合结合可共享叶节点

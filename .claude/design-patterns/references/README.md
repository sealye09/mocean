# 设计模式参考文档

基于《深入设计模式 v2021-1.25》和 TypeScript 实现的完整参考文档。

---

## 快速导航

### 按分类浏览

- **[创建型模式](creational-patterns.md)** (5种)
  处理对象创建机制，增加代码灵活性和可复用性

- **[结构型模式](structural-patterns.md)** (7种)
  介绍如何将对象和类组装成较大的结构

- **[行为模式](behavioral-patterns.md)** (10种)
  负责对象间的高效沟通和职责委派

### 按模式查找

#### 创建型模式

- **[单例](creational/singleton.md)** - 保证类只有一个实例，提供全局访问点
- **[原型](creational/prototype.md)** - 复制已有对象，无需依赖所属类
- **[工厂方法](creational/factory-method.md)** - 定义创建对象的接口，由子类决定实例化类型
- **[建造者](creational/builder.md)** - 分步骤创建复杂对象
- **[抽象工厂](creational/abstract-factory.md)** - 创建一系列相关或依赖对象的家族

#### 结构型模式

- **[适配器](structural/adapter.md)** - 让接口不兼容的对象可以协同工作
- **[桥接](structural/bridge.md)** - 将抽象部分与实现部分分离
- **[组合](structural/composite.md)** - 将对象组合成树形结构以表示部分-整体层次
- **[装饰](structural/decorator.md)** - 动态地为对象添加行为
- **[外观](structural/facade.md)** - 为子系统中的一组接口提供统一接口
- **[享元](structural/flyweight.md)** - 共享对象以减少内存占用
- **[代理](structural/proxy.md)** - 为其他对象提供代理以控制对这个对象的访问

#### 行为模式

- **[责任链](behavioral/chain-of-responsibility.md)** - 将请求沿处理链传递
- **[命令](behavioral/command.md)** - 将请求转换为对象
- **[迭代器](behavioral/iterator.md)** - 遍历集合元素
- **[中介者](behavioral/mediator.md)** - 集中管理对象间的交互
- **[备忘录](behavioral/memento.md)** - 保存和恢复对象状态
- **[观察者](behavioral/observer.md)** - 定义订阅机制，通知多个订阅者
- **[状态](behavioral/state.md)** - 允许对象在内部状态改变时改变行为
- **[策略](behavioral/strategy.md)** - 定义一系列算法，使它们可以互相替换
- **[模板方法](behavioral/template-method.md)** - 在父类中定义算法框架，子类实现具体步骤
- **[访问者](behavioral/visitor.md)** - 在不修改类的前提下定义新操作

---

## 文档结构

每个模式文档包含：

### 理论部分
- **概述**：定义、分类
- **问题场景**：核心问题、示例场景
- **解决方案**：核心思想、设计原理
- **结构**：UML类图、参与者、协作关系

### 实践部分
- **代码示例**：基于实际 TypeScript 代码
  - 概念性实现
  - 实际应用示例
- **适用场景**：何时使用/不使用
- **优缺点**：使用该模式的影响
- **模式关系**：与其他模式的关联
- **TypeScript要点**：语言特性应用

---

## 代码实现

所有模式都有完整的 TypeScript 实现，位于 `src/` 目录：

- **Conceptual**：概念性示例，展示内部结构
- **RealWorld**：实际应用示例
- **Book**：书中经典示例（部分模式）

运行示例：
```bash
ts-node src/[PatternName]/[Conceptual|RealWorld]/index.ts
```

---

## 学习路径

### 初学者
1. 先从简单的**单例**、**工厂方法**开始
2. 理解创建型模式后再学习结构型
3. 最后学习行为模式

### 进阶者
1. 对比相似模式的区别（如工厂方法 vs 抽象工厂）
2. 学习模式组合使用（如工厂方法 + 单例）
3. 在实际项目中应用

### 专家
1. 研究模式的变体实现
2. 理解模式与设计原则的关系
3. 创造性地应用和组合模式

---

## 设计原则参考

良好的软件设计应当遵循：

- **单一职责原则 (SRP)**：一个类只负责一件事
- **开闭原则 (OCP)**：对扩展开放，对修改封闭
- **里氏替换原则 (LSP)**：子类应能替换父类
- **接口隔离原则 (ISP)**：不应强迫实现不用的接口
- **依赖倒置原则 (DIP)**：依赖抽象而非具体实现

---

## 模式速查表

### 创建型模式对比

| 场景 | 推荐模式 | 理由 |
|------|---------|------|
| 只需一个实例 | 单例 | 简单直接 |
| 需要复制对象 | 原型 | 避免重复初始化 |
| 对象构造复杂 | 建造者 | 分步构建 |
| 创建产品系列 | 抽象工厂 | 保证风格一致 |
| 创建单一产品 | 工厂方法 | 灵活简单 |

### 结构型模式对比

| 场景 | 推荐模式 | 理由 |
|------|---------|------|
| 接口不兼容 | 适配器 | 转换接口 |
| 多维度变化 | 桥接 | 分离抽象与实现 |
| 树形结构 | 组合 | 统一处理 |
| 动态添加行为 | 装饰 | 不使用继承 |
| 简化复杂系统 | 外观 | 统一接口 |
| 节省内存 | 享元 | 共享对象 |
| 控制访问 | 代理 | 延迟初始化 |

### 行为模式对比

| 场景 | 推荐模式 | 理由 |
|------|---------|------|
| 请求处理链 | 责任链 | 灵活传递 |
| 命令参数化 | 命令 | 支持撤销 |
| 遍历集合 | 迭代器 | 封装算法 |
| 复杂交互 | 中介者 | 解耦对象 |
| 状态快照 | 备忘录 | 封装保存 |
| 事件通知 | 观察者 | 发布订阅 |
| 状态切换 | 状态 | 封装状态 |
| 算法切换 | 策略 | 可互换 |
| 算法框架 | 模板方法 | 代码复用 |
| 新操作 | 访问者 | 不修改类 |

---

## 参考资源

- **原书**：《深入设计模式 v2021-1.25》
- **网站**：[Refactoring.Guru](https://refactoring.guru/design-patterns)
- **代码**：[src/](../src)
- **项目主页**：[GitHub](https://github.com/)

---

## 贡献指南

欢迎贡献改进和纠错！

1. 查阅现有文档结构和风格
2. 提交 Pull Request
3. 保持文档清晰、准确、实用

---

## 许可证

本项目采用 MIT 许可证。

# 行为模式

行为模式负责对象间的高效沟通和职责委派。

---

## 模式列表

| 模式 | 英文 | 主要用途 | 详细文档 |
|------|------|----------|----------|
| 责任链 | Chain of Responsibility | 将请求沿处理链传递 | [查看 →](behavioral/chain-of-responsibility.md) |
| 命令 | Command | 将请求转换为对象 | [查看 →](behavioral/command.md) |
| 迭代器 | Iterator | 遍历集合元素 | [查看 →](behavioral/iterator.md) |
| 中介者 | Mediator | 集中管理对象间的交互 | [查看 →](behavioral/mediator.md) |
| 备忘录 | Memento | 保存和恢复对象状态 | [查看 →](behavioral/memento.md) |
| 观察者 | Observer | 定义订阅机制，通知多个订阅者 | [查看 →](behavioral/observer.md) |
| 状态 | State | 允许对象在内部状态改变时改变行为 | [查看 →](behavioral/state.md) |
| 策略 | Strategy | 定义一系列算法，使它们可以互相替换 | [查看 →](behavioral/strategy.md) |
| 模板方法 | Template Method | 在父类中定义算法框架，子类实现具体步骤 | [查看 →](behavioral/template-method.md) |
| 访问者 | Visitor | 在不修改类的前提下定义新操作 | [查看 →](behavioral/visitor.md) |

**快速索引**：[行为模式总览](behavioral-patterns.md) | [所有模式文档](README.md)

---

## 行为模式对比

### 按使用场景分类

| 场景 | 推荐模式 | 理由 |
|------|---------|------|
| 请求处理链 | 责任链 | 灵活传递请求，动态指定处理者 |
| 命令参数化 | 命令 | 将请求封装为对象，支持撤销/重做 |
| 遍历集合 | 迭代器 | 统一遍历方式，隐藏内部结构 |
| 复杂交互 | 中介者 | 集中管理对象间交互，降低耦合 |
| 状态快照 | 备忘录 | 保存/恢复状态，不破坏封装 |
| 事件通知 | 观察者 | 一对多依赖，状态变化通知 |
| 状态驱动 | 状态 | 封装状态，状态切换改变行为 |
| 算法切换 | 策略 | 算法可互换，运行时选择 |
| 算法框架 | 模板方法 | 定义框架，子类实现步骤 |
| 新操作 | 访问者 | 不修改类，添加新操作 |

---

## 代码实现

所有行为模式都有完整的 TypeScript 实现，位于 `src/` 目录：

### 运行示例

```bash
# 责任链模式
ts-node src/ChainOfResponsibility/Conceptual/index.ts

# 命令模式
ts-node src/Command/Conceptual/index.ts

# 迭代器模式
ts-node src/Iterator/Conceptual/index.ts

# 中介者模式
ts-node src/Mediator/Conceptual/index.ts

# 备忘录模式
ts-node src/Memento/Conceptual/index.ts

# 观察者模式
ts-node src/Observer/Conceptual/index.ts

# 状态模式
ts-node src/State/Conceptual/index.ts

# 策略模式
ts-node src/Strategy/Conceptual/index.ts

# 模板方法模式
ts-node src/TemplateMethod/Conceptual/index.ts

# 访问者模式
ts-node src/Visitor/Conceptual/index.ts
```

---

## 相关资源

- [全部行为模式详细文档](behavioral/)
- [设计模式总览](README.md)

---

## 责任链 (Chain of Responsibility)

**定义**：将请求沿处理链传递，直到有对象处理它。

**核心问题**：多个对象可以处理请求，但不知道具体由哪个处理，且处理者需要动态指定。

**解决方案**：
- 将处理者连成一条链
- 每个处理者处理请求或传递给下一个
- 客户端将请求传递给链的第一个处理者

**适用场景**：
- 多个对象可以处理同一请求
- 需要动态指定处理者集合
- 请求必须按特定顺序处理

**结构要点**：
- `Handler`：处理者接口，声明处理方法和 successor 引用
- `ConcreteHandler`：具体处理者，实现处理逻辑
- `Client`：向链的第一个处理者发起请求

---

## 命令 (Command)

**定义**：将请求转换为对象，从而允许用不同的请求对客户进行参数化。

**核心问题**：需要将操作请求封装成对象，以支持排队、日志、撤销等操作。

**解决方案**：
- 声明命令接口，包含执行方法
- 具体命令实现接口，封装接收者和操作
- 调用者持有命令并执行
- 支持撤销操作

**适用场景**：
- 需要将操作请求参数化
- 需要支持操作队列/日志/撤销
- 需要将操作调用者与接收者解耦

**结构要点**：
- `Command`：命令接口
- `ConcreteCommand`：具体命令，绑定接收者和动作
- `Invoker`：调用者，持有命令并执行
- `Receiver`：接收者，执行实际工作

---

## 迭代器 (Iterator)

**定义**：在不暴露集合底层结构的情况下，遍历集合元素。

**核心问题**：需要遍历集合，但不希望暴露其内部结构。

**解决方案**：
- 声明迭代器接口，定义遍历方法
- 具体迭代器实现遍历算法
- 集合返回迭代器实例
- 支持多种遍历方式

**适用场景**：
- 需要遍历复杂集合结构
- 需要多种遍历方式
- 希望隐藏集合实现细节

**结构要点**：
- `Iterator`：迭代器接口
- `ConcreteIterator`：具体迭代器
- `Collection`：集合接口，返回迭代器
- `Client`：通过迭代器访问元素

**注意**：现代语言多已内置迭代器支持。

---

## 中介者 (Mediator)

**定义**：集中管理对象间的交互，避免对象直接相互依赖。

**核心问题**：多个对象之间存在复杂的交互关系，导致代码难以维护。

**解决方案**：
- 创建中介者类
- 对象只与中介者交互
- 中介者协调对象间的通信

**适用场景**：
- 对象间存在复杂引用关系
- 需要复用对象但难以依赖其类
- 需要集中控制交互逻辑

**结构要点**：
- `Mediator`：中介者接口
- `ConcreteMediator`：具体中介者，协调对象
- `Colleague`：同事类，只与中介者交互
- `Client`：使用同事类

**与外观区别**：中介者双向通信，外观单向简化调用。

---

## 备忘录 (Memento)

**定义**：保存对象状态，之后恢复而不破坏封装。

**核心问题**：需要实现撤销/恢复功能，但直接访问对象私有状态会破坏封装。

**解决方案**：
- 原发器创建备忘录保存自身状态
- 备忘录存储内部状态，不暴露实现
- 负责人管理备忘录历史
- 原发器从备忘录恢复状态

**适用场景**：
- 需要保存对象状态的快照
- 直接访问对象状态会破坏封装
- 需要实现撤销/恢复功能

**结构要点**：
- `Memento`：备忘录，存储原发者状态
- `Originator`：原发者，创建和恢复备忘录
- `Caretaker`：负责人，管理备忘录历史

---

## 观察者 (Observer)

**定义**：定义订阅机制，当对象事件发生时通知多个"观察"该对象的其他对象。

**核心问题**：一个对象状态改变需要通知其他对象，但不知道需要通知多少个对象。

**解决方案**：
- 发布者维护订阅者列表
- 订阅者实现统一接口
- 发布者状态改变时通知所有订阅者
- 订阅者可动态订阅/取消订阅

**适用场景**：
- 对象状态改变需要通知其他对象
- 对象数量未知或动态变化
- 需要松耦合的事件系统

**结构要点**：
- `Publisher`：发布者，维护订阅者列表
- `Subscriber`：订阅者接口，声明更新方法
- `ConcreteSubscriber`：具体订阅者
- `Client`：创建订阅关系

**常见别称**：发布-订阅、事件监听器。

---

## 状态 (State)

**定义**：允许对象在内部状态改变时改变行为。

**核心问题**：对象的行为依赖于其状态，且需要在运行时根据状态改变行为。

**解决方案**：
- 为每个状态创建独立类
- 上下文持有当前状态对象
- 状态转换时切换状态对象
- 将状态相关行为委派给状态对象

**适用场景**：
- 对象行为依赖于其状态
- 代码中包含大量条件语句处理状态
- 状态需要频繁切换

**结构要点**：
- `State`：状态接口
- `ConcreteState`：具体状态，实现状态行为
- `Context`：上下文，持有当前状态

**与策略区别**：状态可相互切换，策略相互独立。

---

## 策略 (Strategy)

**定义**：定义一系列算法，使它们可以互相替换。

**核心问题**：有多种算法实现同一功能，但需要灵活切换。

**解决方案**：
- 声明策略接口
- 每个算法实现为独立策略类
- 上下文持有策略引用
- 客户端选择策略

**适用场景**：
- 有多种算法完成同一任务
- 需要在运行时切换算法
- 算法包含大量条件语句

**结构要点**：
- `Strategy`：策略接口
- `ConcreteStrategy`：具体策略
- `Context`：上下文，使用策略

**关键**：算法可互换，客户端选择策略。

---

## 模板方法 (Template Method)

**定义**：在父类中定义算法框架，将某些步骤延迟到子类。

**核心问题**：多个类有相似算法，但部分步骤实现不同。

**解决方案**：
- 在父类中定义算法骨架
- 将可变步骤声明为抽象方法
- 子类实现抽象步骤
- 钩子方法提供扩展点

**适用场景**：
- 多个类有相似算法流程
- 需要控制子类扩展点
- 避免代码重复

**结构要点**：
- `AbstractClass`：抽象类，定义模板方法
- `ConcreteClass`：具体类，实现可变步骤

**关键**：基于继承，代码复用；策略基于组合，算法互换。

---

## 访问者 (Visitor)

**定义**：在不修改类的前提下定义新操作。

**核心问题**：需要对对象结构中的对象进行操作，但不希望将这些操作放入这些类中。

**解决方案**：
- 声明访问者接口，为每个元素类型声明访问方法
- 具体访问者实现操作
- 元素声明接受方法
- 双重分派实现动态绑定

**适用场景**：
- 需要对复杂对象结构执行操作
- 操作类型经常变化
- 对象结构稳定但操作易变

**结构要点**：
- `Visitor`：访问者接口
- `ConcreteVisitor`：具体访问者
- `Element`：元素接口，声明 accept 方法
- `ConcreteElement`：具体元素

**缺点**：增加新元素类型困难，违反开闭原则。

---

## 行为模式关系

- 责任链、命令、中介者、观察者处理不同连接方式
- 命令和策略都可参数化，但意图不同
- 状态是策略的扩展，允许状态间切换
- 模板方法基于继承，策略基于组合
- 迭代器用于遍历，访问者用于操作
- 中介者和观察者都管理依赖，但方式不同
